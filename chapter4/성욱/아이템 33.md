# string 타입보다 더 구체적인 타입 사용하기

날짜 형식은 string 보다는 Date 객체로 제한 하는 것이 좋다.
타입 필드는 제한할 수 있으면 유니온 타입으로 정의하자.
제네릭 사용할 때 반환 타입에 유의하자.

유니온 타입을 지정할 때 enum을 사용할 수도 있지만 일반적으로 추천하지는 않는다 (아이템 53 참고)

구체적인 타입을 사용했을 때 장점:

1. 다른 곳으로 값이 전달되어도 타입 정보가 유지된다. string을 쓰면 무슨 타입이 될 수 있는지 알 수 없음
2. 해당 타입의 의미를 설명하는 주석을 만들 수 있다
3. keyof 연산자로 더 세밀하게 객체의 속성 체크가 가능해진다

```
function pluck(records, key) {
	return records.map(r => r[key]);
}

// any 타입이 사용되어 정밀하지 못함
function pluck(records: any[], key: string): any[] {
	return records.map(r => r[key]);
}

// 제네릭 사용으로 개선
function pluck<T>(records: T[], key: string): any[] {
	return records.map(r => r[key]); // '{}' 형식에는 인덱스 시그니처가 없어 암시적으로 'any' 형식이 있다
}

// keyof를 사용하여 키의 any 타입 개선
// 타입스크립트가 반환 타입을 추론 (T[keyof T][])
// const releaseDates = pluck(albums, 'releaseDate'); 타입이 (string | Date)[]
function pluck<T>(records: T[], key: keyof T) {
	return records.map(r => r[key]);
}

// 반환 타입 개선
// K 가 T의 실제 키 중 하나임을 보장
function pluck<T, K extends keyof T>(records: T[], key: K): T[K][] {
	return records.map(r => r[key]);
}
```

