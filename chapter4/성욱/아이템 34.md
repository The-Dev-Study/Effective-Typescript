# 부정확한 타입보다는 미완성 타입을 사용하기

실수가 발생하기 쉽고 잘못된 타입은 없느니만 못하다.

```
interface Point {
	type: 'Point';
	coordinates: number[];
}
// ...
```

number[]가 추상적이다.
튜플 타입으로 선언하는게 나아보인다

```
type GeoPosition = [number, number];
interface Point {
	type: 'Point';
	coordinates: GeoPosition;
}
// ...
```

하지만 3번째 요소로 고도가 있거나 추가적인 정보가 있을 수 있어 오히려 타입이 부정확해졌다.
다른 사용자가 사용하려면 타입 단언문을 도입하거나 as any를 추가해서 타입 체커를 무시해야 한다.

```
type Expression1 = any;
type Expression2 = number | string | any[];

type FnName = '+' | '-' | '*' | '/' | '>' | '<' | 'case' | 'rgb';
type Expression3 = number | string | CallExpression;

const tests: Expression2[] = [
	12,
	"red",
	true, // 타입 오류
	["+", 1, 2], // 3
	["/", 20, 2], // 10
	["case", [">", 20, 10], "red", "blue"], // "red"
	["rgb", 255, 0, 127] // "#FF007F"
]
```

새 타입을 할수록 더 구체적이지만 자동 완성을 방해하기 때문에 타입스크립트 개발 경험을 해친다.
타입 선언의 복잡성은 버그를 발생시킬 가능성을 높히고 더 정밀하게 만들려던 시도로 코드가 더 부정확해질 수 있다.
정확하게 타입을 모델링할 수 없다면 부정확하게 모델링하지 말아야하고 any와 unknown은 구별해서 사용해야 한다.