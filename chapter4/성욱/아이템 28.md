# 유효한 상태만 표현하는 타입을 지향하기

효과적으로 타입을 설계하기 위해서는 유효한 상태만 표현할 수 있는 타입을 만드는 것이 가장 중요하다.

유효하지 않은 상태 관리:

```
// 에러와 로딩 상태가 같이 존재함
interface State {
	pageText: string;
	isLoading: boolean;
	error?: string;
}

function renderPage(state: State) {
	if (state.error) {
		return `Error! Unable to load ${state.error}`;
	} else if (state.isLoading) {
		return `Loading`;
	}
	return `<h1>${currentPage}</h1>`
}

// 1. isLoading false 설정하는 로직 없음
// 2. error를 초기화하지 않음
// 3. 로딩 중 페이지 전환되면 undefined behavior
async function changePage(state: State, newPage: string) {
	state.isLoading = true;
	try {
		const response = await fetch(getUrlForPage(newPage));
		if (!response.ok) {
			throw new Error(`Unable to load new page`);
		}
		const text = await response.text();
		state.isLoading = false;
		state.pageText = text;
	} catch (e) {
		state.error = '' + e;
	}
}
```

개선된 버전:

```
// 로딩 상태만 존재
interface RequestPending {
	state: 'pending';
}
// 에러 상태만 존재
interface RequestError {
	state: 'error';
	error: string;
}
// ok 상태와 해당 페이지 데이터 존재
interface RequestSuccess {
	state: 'ok';
	pageText: string;
}
type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
	currentPage: string;
	requests: {[page: string]: RequestState};
}

function renderPage(state: State) {
	const {currentPage} = state;
	const requestState = state.requests[currentPage];
	switch (requestState.state) {
		case 'pending':
			return `Loading`;
		case 'error':
			return `Error`;
		case 'ok':
			return `<h1>${currentPage}</h1>`
	}
}

async function changePage(state: State, newPage: string) {
	state.requests[newPage] = {state: 'pending'};
	state.currentPage = newPage;
	try {
		const response = await fetch(getUrlForPage(newPage));
		if (!response.ok) {
			throw new Error(`error status`);
		}
		const pageText = await response.text();
		state.requests[newPage] = {state: 'ok', pageText};
	} catch (e) {
		state.requests[newPage] = {state: 'error', error: '' + e};
	}
}
```

다음 예시는 기장과 부기장이 같은 조종대를 붙잡고 조종하는데 두 조종대의 각도의 합으로 컨트롤하는 경우이다. 결론적으로 의도치 않은 동작을 발생시키기 때문에 두 조종대는 동기화될 필요가 있다.

interface CockpitControls {
leftSideStick: number;
rightSideStick: number;
}

// 기장
function getStickSetting(controls: CockpitControls) {
return controls.leftSideStick;
}

// 부기장
function getStickSetting(controls: CockpitControls) {
const {leftSideStick, rightSideStick} = controls;
if (leftSideStick === 0) {
return rightSideStick;
}
return leftSideStick;
}

// 둘 다 중립일 경우에는..?
function getStickSetting(controls: CockpitControls) {
const {leftSideStick, rightSideStick} = controls;
if (leftSideStick === 0) {
return rightSideStick;
} else if (rightSideStick === 0) {
return leftSideStick;
}
// ...
}
