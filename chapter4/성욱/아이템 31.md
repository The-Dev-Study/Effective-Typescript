# 타입 주변에 null 값 배치하기

값이 전부 null이거나 전부 null이 아닌 경우로 분명히 구분되면 다루기 쉽다.

API값은 반환 타입 전체가 null이거나 null이 아닌 타입으로 만들자.
클래스를 만들 때는 null로 초기화하는 것이 아닌 값을 모두 받아 초기화하자.
strictNullChecks를 설정하는게 null관련 문제점을 찾아내기 쉬워진다.

```
function extent(nums: number[]) {
	let min, max;
	for (const num of nums) {
		if (!min) {
			min = num;
			max = num;
		} else {
			min = Math.min(min, num);
			max = Math.max(max, num); // strictNullChecks 설정하면 타입 에러 (number | undefined는 number 타입에 할당될 수 없음)
		}
	}
	return [min, max];
}
```

반환 타입이 number[]로 추론되지만 문제가 있다.

1. 최솟값이나 최댓값이 0인 경우 값이 덧씌워진다. ex) extent([0, 1, 2])의 결과는 [0, 2]가 아닌 [1, 2]가 된다.
2. nums 배열이 비어 있다면 함수는 [undefined, undefined]를 반환한다.

개선된 코드:

```
function extent(nums: number[]) {
	let result: [number, number] | null = null;
	// ...
}
``` 


2번째 예시:

```
class UserPosts {
	user: UserInfo | null;
	posts: Post[] | null;

	// 초기값이 null
	constructor() {
		this.user = null;
		this.posts = null;
	}

	async init(userId: string) {
		return Promise.all([
			async () => this.user = await fetchUser(userId),
			async () => this.posts = await fechPostsForUser(userId)
		]);
	}

	getUserName() {
		// ...
	}
}
```

개선된 코드:

```
class UserPosts {
	user: UserInfo;
	posts: Post[];

	// 초기값은 null이 아닌 값
	constructor(user: UserInfo, posts: Post[]) {
		this.user = user;
		this.posts = posts;
	}

	static async init(userId: string): Promise<UserPosts> {
		// 올바른 Promise 사용
		const [user, posts] = await Promise.all([
			fetchUser(userId),
			fetchPostsForUser(userId)
		]);
		return new UserPosts(user, posts);
	}

	getUserName() {
		return this.user.name;
	}
}
```