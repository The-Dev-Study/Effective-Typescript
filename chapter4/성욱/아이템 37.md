# 공식 명칭에는 상표를 붙이기

구조적 타이핑 때문에 가끔 코드가 이상한 결과를 낸다.

```
interface Vector2D {
	x: number;
	y: number;
}
function calculateNorm(p: Vector2D) {
	return Math.sqrt(p.x * p.x + p.y * p.y);
}

calculateNorm({x: 3, y: 4}); // 결과: 5
const vec3D = {x: 3, y: 4, z: 1};
calculateNorm(vec3D); // 결과: 5
```

구조적 타이핑 관점에서는 문제가 없지만 수학적으로 따졌을 때 결과가 다르다.
이럴 때 상표를 붙이면 된다.

```
interface Vector2D {
	_brand: '2d';
	x: number;
	y: number;
}
function vec2D(x: number, y: number): Vector2D {
	return {x, y, _brand: '2d'};
}
function calculateNorm(p: Vector2D) {
	return Math.sqrt(p.x * p.x + p.y * p.y);
}

calculateNorm(vec2D(3, 4)); // 정상
const vec3D = {x: 3, y: 4, z: 1};
calculateNorm(vec3D); // 타입 에러 '_brand' 속성이 없습니다.
```

단수 실수 방지용이다.
타입 시스템이기 때문에 런타임 오버헤드를 없앨 수 있고 추가 속성을 붙일 수 없는 string이나 number 같은 내장 타입도 상표화할 수 있다.

```
type AbsolutePath = string & {_brand: 'abs'};
function listAbsolutePath(path: AbsolutePath) {
	// ...
}
function isAbsolutePath(path: string): path is AbsolutePath {
	return path.startsWith('/');
}

function f(path: string) {
	if (isAbsolutePath(path)) {
		listAbolutePath(path);
	}
	listAbsolutePath(path); // 'string' 형식은 'AbsolutePath' 형식의 매개벼수에 할당될 수 없습니다.
}
```

`path as AbolutePath` 같은 단언문은 지양해야 한다.

```
type Meters = number & {_brand: 'meters'};
type Seconds = number & {_brand: 'seconds'};

const meters = (m: number) => m as Meters;
const seconds = (s: number) => s as Seconds;

const oneKm = meters(1000); // Meters 타입
const oneMin = seconds(60); // Seconds 타입

cont tenKm = oneKm * 10; // number 타입
cont v = oneKm / oneMin; // number 타입
```