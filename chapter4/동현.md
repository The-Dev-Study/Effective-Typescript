## 아이템 28. 유효한 상태만 표현하는 타입을 지향하기

불가능한/에러유발 상태는 사전에 차단해서 설계해야함

### 문제가 있는 설계

```tsx
interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}
```

- `isLoading`이 `true`이면서 `error`가 존재하는 무효한 상태 허용
- 상태 간의 관계가 불분명

### 개선된 설계: 태그된 유니온 사용

```tsx
interface RequestPending {
  state: 'pending';
}

interface RequestError {
  state: 'error';
  error: string;
}

interface RequestSuccess {
  state: 'success';
  pageText: string;
}

type RequestState = RequestPending | RequestError | RequestSuccess;

```

**적용 시점**: API 응답 상태, 폼 유효성 검사 등에서 유효한 상태만 표현

---

## 아이템 29. 사용할 때는 너그럽게, 생성할 때는 엄격하게

매개변수는 유연하게, 반환값은 엄격하게 설계하기

### 매개변수는 넓게

```tsx
type LngLatLike = LngLat | { lon: number; lat: number } | [number, number];

interface CameraOptions {
  center?: LngLatLike;  // 다양한 형태 허용
  zoom?: number;
  bearing?: number;
  pitch?: number;
}

```

### 반환값은 엄격하게

```tsx
interface Camera {
  center: LngLat;  // 정확한 타입만 반환
  zoom: number;
  bearing: number;
  pitch: number;
}

```

**적용 시점**: 외부 데이터 처리, 복잡한 입력 형태를 허용하는 함수

---

## 아이템 30. 문서에 타입 정보를 쓰지 않기

타입 시스템으로 이해가 충분하게 설계하기, 불필요한 주석 넣어서 헷갈리게 만들지 않기

### 잘못된 예시

```tsx
/** nums를 변경하지 않습니다. */
function sort(nums: number[]) {
  // 구현부
}

```

### 개선된 예시

```tsx
function sort(nums: readonly number[]): number[] {
  // 구현부
}

```

**적용 시점**: 불변성, 타입 안전성을 명시적으로 표현할 때

---

## 아이템 31. 타입 주변에 null 값 배치하기

값이 전부 null이거나 전부 null이 아닌 상태로 명확히 구분하기

### 문제가 있는 설계

```tsx
function extent(nums: number[]) {
  let min, max;
  // min과 max가 섞여있는 상태
}

```

### 개선된 설계

```tsx
function extent(nums: number[]): [number, number] | null {
  let result: [number, number] | null = null;
  for (const num of nums) {
    if (!result) {
      result = [num, num];
    } else {
      result = [Math.min(num, result[0]), Math.max(num, result[1])];
    }
  }
  return result;
}

```

---

## 아이템 32. 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기

여러 속성이 연관된 경우 인터페이스의 유니온을 사용하기

### 문제가 있는 설계

```tsx
interface Layer {
  type: 'fill' | 'line' | 'point';
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}

```

- `type`과 `layout`, `paint` 간의 관계가 불분명

### 개선된 설계

```tsx
interface FillLayer {
  type: 'fill';
  layout: FillLayout;
  paint: FillPaint;
}

interface LineLayer {
  type: 'line';
  layout: LineLayout;
  paint: LinePaint;
}

interface PointLayer {
  type: 'point';
  layout: PointLayout;
  paint: PointPaint;
}

type Layer = FillLayer | LineLayer | PointLayer;

```

**적용 시점**: 여러 속성이 서로 연관된 경우

---

## 아이템 33. string 타입보다 더 구체적인 타입 사용하기

모든 문자열을 허용하는 `string`보다 타입을 좁혀서 사용

### 문자열 리터럴 타입 사용

```tsx
type Role = 'admin' | 'user' | 'guest';

function getPermissions(role: Role): string {
  const permissions: { [key in Role]: string } = {
    admin: 'Full Access',
    user: 'Limited Access',
    guest: 'Guest Access',
  };
  return permissions[role];
}

```

### 제네릭 + keyof 연산자 활용

```tsx
function pluck<T, K extends keyof T>(record: T[], key: K): T[K][] {
  return record.map(r => r[key]);
}
```

저 keyof는 string | number | symbol 타입이라 keyof T를 사용할때 주의해야 함(react key 등으로 사용시 symbol 안들어감)

Extract로 특정 타입을 제한해 사용 가능하다

---

## 아이템 34. 부정확한 타입보다는 미완성 타입을 사용하기

### 기본 원칙

- 정확한 타입을 선언할 수 없다면 타입 추론에 의존
- `any`와 `unknown`을 구별해서 사용
- 타입이 없는 것이 잘못된 타입보다 낫다

정확한 타입을 정의하기 어려운 상황

---

## 아이템 35. 데이터보다는 명세로부터 코드를 생성하기

런타임 데이터가 아닌 스키마를 참고해 타입을 생성하기

### 명세 기반 타입 생성

```tsx
// API 스키마나 OpenAPI 스키마 활용
import { Feature } from 'geojson';

// GraphQL 스키마를 활용한 타입 생성
// Apollo 등의 도구 사용

```

**적용 시점**: API 연동, 외부 데이터 스키마 정의

---

## 아이템 36. 해당 분야의 용어로 타입 이름 짓기

일반적인 이름보다 해당 분야의 전문 용어를 사용하기

### 개선 예시

```tsx
// 개선 전
interface Data {
  id: number;
  value: string;
}

// 개선 후 (도메인 용어 사용)
interface Product {
  productId: number;
  productName: string;
}

```

### 네이밍 원칙

- 동일한 의미를 나타낼 때는 같은 용어 사용
- `data`, `info`, `thing` 같은 제너럴한 이름 피하기
- 도메인 전문 용어 활용

---

## 아이템 37. 공식 명칭에는 상표를 붙이기 (브랜딩)

브랜딩 기법으로 더 구체적이고 안전한 타입을 정의하기

이거 쓸 일이 있으려나? 참신한데 이 방식 없이도 충분히 가능할 것 같음 타입 좁히기로

### 기본 타입 브랜딩

```tsx
type UserId = number & { readonly brand: unique symbol };
type OrderId = string & { readonly brand: unique symbol };

declare function createUserId(id: number): UserId;
declare function getUserById(id: UserId): UserInfo;

// 사용 예시
const id = createUserId(123);
getUserById(id); // 정상
getUserById(123); // 오류: 일반 number는 허용되지 않음

```

### 도메인 특화 브랜딩

```tsx
type Meters = number & { readonly brand: 'meters' };
type Seconds = number & { readonly brand: 'seconds' };

const meters = (m: number) => m as Meters;
const seconds = (s: number) => s as Seconds;

```

---

## 소감

이번 단원은 응용 느낌이였다.

타입설계를 명확하게 해 사이드이펙트를 제거하는 많은 사례들을 볼 수 있었다. 특히 조정간 저거는 매우 골때리는 부분… 이 책에서 예시를 잘 드는것 같다

유니온의 인터페이스는 딱 봐도 불안불안해 보이는데 저렇게 짜면 리팩토링할때 골치아플 듯

제너럴한 이름 피하기는 입사후 고친 안좋은 습관중 하나라 반가웠다

브랜딩 기법은 참신했으나 저 방식이 최고성능의 트레이드오프인 상황이 생각나지 않는다. 타입 상속/제네릭으로 커버 가능해보임
