# 타입스크립트 기능보다는 ECMAScript 기능 사용하기

자바스크립트는 초기에 결함이 많고 개선해야 할 부분이 많았다.

클래스, 데코레이터, 모듈 시스템 같은 기능이 없어 프레임워크나 트랜스파일러로 보완하는 것이 일반적이었다.

타입스크립트 팀은 "초기 버전의 형태 유지, 신규 기능을 변형해서 끼워 맞추기" vs "신규 기능을 그대로 채택, 타입스크립트 초기 버전 호환성 포기" 두가지 중 후자를 선택했다.

이로 인해 몇 가지 기능이 호환성 문제를 야기시킬 수 있다.

### 열거형 (enum)

단순히 값을 나열하는 것보다 실수가 적고 명확해 일반적으로 사용하는 것이 좋지만
`타입스크립트의 열거형`은 몇 가지 문제가 있다.
- 숫자 열거형에 0, 1, 2 외의 다른 숫자가 할당되면 매우 위험하다 (원래 비트 플래그 구조를 표현하기 위해 설계되었다)
- 상수 열거형은 보통의 열거형과 달리 런타임에 완전히 제거된다.
- preserveConstEnums 플래그를 설정한 상태의 상수 열거형은 보통의 열거형처럼 런타임 코드에 상수 열거형 정보를 유지한다.
- 문자열 열거형은 런타임의 타입 안정성과 투명성을 제공하지만 타입스크립트의 다른 타입과 달리 구조적 타이핑이 아닌 명목적 타이핑을 사용한다.

```typescript
enum Flavor {
	VANILLA = 0,
	CHOCOLATE = 1,
	STRAWBERRY = 2,
}

let flavor = Flavor.CHOCOLATE; // type: Flavor

FLAVOR[0] // VANILLA

cons enum Flavor {
	VANILLA = 0,
	CHOCOLATE = 1,
	STRAWBERRRY = 2,
}

Flavor.CHOCOLATE // 0

```

열거형 대신 유니온 타입을 ㅏ용하는 것이 좋다

```typescript
type Flavor = 'vanilla' | 'chocolate' | 'strawberry';

let flavor: Flavor = 'chocolate';

```

### 매개변수 속성

```typescript
// javascript
class Person {
	name: string;
	constructor(name: string) {
		this.name = name;
	}
}

// typescript
class Person {
	consructor(public name: string) {}
}

// 섞어 사용될 경우 설계가 혼란스러움
class Person {
	first: string;
	last: string;
	constructor(public name: string) {
		[this.first, this.last] = name.split(' ');
	}
}
```

### 네임스페이스와 트리플 슬래시 임포트

ECMAScript 2015 이전에는 공식 모듈 시스템이 없었다.

Node.js는 require, module.exports를 사용하고
AMD는 define 함수와 콜백을 사용했다

타입스크립트 역시 자체적으로 모듈 시스템을 구축했고 `module` 키워드와 `트리플 슬래시` 임포트를 사용했다. ECMAScript 2015 이후 충돌을 피하기 위해 `namespace` 키워드를 추가했다.

```typescript
namespace foo {
	function bar() {}
}

foo.bar();
```

### 데코레이터

```typescript
class Greeter {
	greeting: string;
	constructor(message: string) {
		this.greeting = message;
	}
	@logged
	greet() {
		return "Hello, " + this.greeting;
	}
}
```

처음에 앵귤러 프레임워크를 지원하기 위해 추가되었으며 tsconfig.json에 `experimentalDecorators` 속성을 설정하고 사용해야 했다. 현재까지도 표준화가 완료되지는 않아 호환성이 깨질 가능성이 있다. 따라서 앵귤러나 애너테이션이 필요한 프레임워크를 사용하고 있지 않다면 사용하지 않는게 좋다.