# 2장: 타입스크립트의 타입 시스템

> 타입 = 할당 가능한 값들의 집합 / 할당 가능한 값의 범위

## 7. 타입은 값들의 집합

### `Never` - 공집합

-   가장 작은 집합으로 아무 값도 포함하지 않는다.
-   값을 할당할 수 없다.

### 리터럴 타입

-   공집합 다음으로 작은 타입으로 **한 가지 값**만 갖도록 제한하는 타입이다.
-   유닛 타입이라고도 불린다.

```ts
let numA: 10 = 10; // numA는 10만을 저장할 수 있음
type A = 'A';
```

### 타입 체커와 집합

타입체커의 주요 역할은 **하나의 집합이 다른 집합의 부분 집합인지를 검사하는 것**이다.

```ts
type AB = 'A' | 'B';
const a: AB = 'A'; // 'A'는 집합 { 'A', 'B' }의 부분 집합이다.
const a: AB = 'C'; // 'C'는 집합 { 'A', 'B' }의 부분 집합이 아니다.
```

### keyof 연산자를 대수 타입에 적용하기

```ts
keyof (A & B) = (keyof A) ∪ (keyof B)
keyof (A | B) = (keyof A) ∩ (keyof B) // 개발 때 잘 안씀
```

### `extends` 키워드 이해하기

프로퍼티가 더 적은 타입을 **슈퍼타입**, 프로퍼티가 더 많은 타입을 **서브타입**이라고 한다. 집합의 관점에서 서브 타입의 값들의 집합이 슈퍼 타입의 값들의 집합의 부분집합이다.

> `interface 서브 타입 extends 슈퍼 타입`이 되는거임

### 튜플의 `length`속성 타입

`triple`에 숫자가 3개 있으니까 앞의 2개만 가져오면 되지 않을까라고 생각했지만, 에러가 발생한다.

```ts
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple;
// 에러: 'length' 속성의 형식이 호환되지 않습니다.
// 형식 '3'을(를) 형식 '2'에 할당할 수 없습니다.
```

-   오류가 발생하는 이유: 튜플은 `length`속성이 정확한 **숫자 리터럴 타입**이다. `length` 타입이 다르기 때문에 할당 안됨
    -   `triple`의 `length`속성 타입은 **3**
    -   `double`의 `length`속성 타입은 **2**

| 타입스크립트 용어            | 집합 용어                     |
| ---------------------------- | ----------------------------- |
| never                        | ∅(공집합)                     |
| 리터럴 타입                  | 원소가 1개인 집합             |
| 값이 T에 할당 가능           | 값 ∈ T (값이 T의 원소)        |
| T1이 T2에 할당 가능          | T1 ⊆ T2 (T1이 T2의 부분 집합) |
| T1이 T2를 상속               | T1 ⊆ T2 (T1이 T2의 부분 집합) |
| T1 \| T2 (T1과 T2의 유니온)  | T1 ∪ T2 (T1과 T2의 합집합)    |
| T1 & T2 (T1과 T2의 인터섹션) | T1 ∩ T2 (T1과 T2의 교집합)    |
| unknown                      | 전체(universal) 집합          |

표 2-1 타입스크립트 용어와 집합 용어

## 8. 타입 공간과 값공간의 심벌 구분

타입스크립트에서는 **같은 이름**이 **두 가지 다른 의미**로 사용될 수 있다.

```ts
// 값 공간의 Cylinder (실제 객체)
const Cylinder = {
    radius: 1,
    height: 5,
};

// 타입 공간의 Cylinder (타입 정의)
interface Cylinder {
    radius: number;
    height: number;
}
```

-   심볼이 어떤 공간에 해당하는지 확인하려면 **플레이그라운드**를 활용하면 됨
    -   자바스크립트 코드로 변환했을 때 사라지면 **타입 심볼**!
-   `=` 뒤에 나오는 심벌은 **값**이다.
-   `as`나 `:` 뒤에 나오는 심벌은 **타입**이다.

### class와 enum

`class`와 `enum`은 타입 공간과 값 공간 모두에서 사용이 가능하다.

```ts
// 타입 공간의 Cylinder (컴파일 타임에만 존재)
interface Cylinder {
    radius: number;
    height: number;
}

// 값 공간의 Cylinder (런타임에 실제 존재)
const Cylinder = (radius: number, height: number) => ({ radius, height });

function calculateVolume(shape: unknown) {
    if (shape instanceof Cylinder) {
        // instanceof는 값 공간에서만 동작하는 런타임 연산자
        // 여기서 Cylinder는 함수를 의미함!
        shape.radius;
        //    ~~~~~~ Property 'radius' does not exist on type '{}'
    }
}
```

-   여기서 `interface`대신 `class`를 사용해주면 해결됨

```ts
class Cylinder {
    radius: number;
    height: number;
    constructor(radius: number, height: number) {
        this.radius = radius;
        this.height = height;
    }
}

function calculateVolume(shape: unknown) {
    if (shape instanceof Cylinder) {
        shape;
        // ^? (parameter) shape: Cylinder
        shape.radius;
        //    ^? (property) Cylinder.radius: number
    }
}
```

### `typeof`

원시 타입 vs 객체 타입

#### 값 공간

```ts
const person = { name: '김철수', age: 30 };
const email = (to: string) => `Hello ${to}`;

console.log(typeof person); // "object"
console.log(typeof email); // "function"
```

### 타입 공간

```ts
const person = { name: '김철수', age: 30 };
const email = (to: string) => `Hello ${to}`;

type PersonType = typeof person; // person이 원시타입이 아님으로
// { name: string; age: number; }

type EmailType = typeof email;
// (to: string) => string
```

```ts
// 예시 데이터
const user = { id: 1, name: 'Alice' };
const sendEmail = (recipient: string) => console.log(`Email to ${recipient}`);

// 값 공간에서 typeof - 런타임 타입 체크
if (typeof user === 'object') {
    console.log('user는 객체입니다');
}

if (typeof sendEmail === 'function') {
    console.log('sendEmail은 함수입니다');
}

// 타입 공간에서 typeof - 컴파일 타임 타입 추출
type UserType = typeof user; // { id: number; name: string; }
type EmailFunc = typeof sendEmail; // (recipient: string) => void
```

-   런타임에 `typeof`를 쓰면 6개의 타입 중 하나가 됨. `string`, `number`, `boolean`, `undefined`, `object`, `function`

#### 클래스의 이중 정체성

JavaScript로 컴파일되면 클래스는 실제로 **함수**가 된다.

```ts
class Cylinder {
    radius = 1;
    height = 1;
}

// 값 공간 (런타임)
const v = typeof Cylinder; // "function" (문자열)
console.log(v); // "function" 출력

// 타입 공간 (컴파일타임)
type T = typeof Cylinder; // 생성자 함수 타입
// T = { new(): Cylinder } 같은 형태
```

-   클래스는 실제로 생성자 함수이기 때문에 값공간(런타임)에서는 "function" string이 된다.
-   클래스는 타입 공간에서는 `typeof 클래스 이름`을 하면 **생성자 함수의 타입**이 된다.

## 9. 타입 단언보다는 타입 선언을 사용하기

**타입 단언**은 개발자가 해당 타입에 대해 확신이 있을 때 사용하는 타입 지정 방식이다.

```ts
interface Person {
    name: string;
}

const bob = { name: 'bob' } as Person;
```

-   타입스크립트가 추론한 타입이 있더라도 `Person`으로 간주한다.
-   타입 체커가 오류를 무시함

**타입 선언**은 할당되는 값이 인터페이스를 만족하는지 검사한다.

### 타입 단언이 필요한 경우

타입스크립트는 DOM에 접근할 수 없기 때문에 DOM 엘리먼트를 사용할 때는 타입 단언이 필요하다.

```ts
document.querySelector('#myButton').addEventListener('click', (e) => {
    e.currentTarget; // 타입은 EventTarget | null
    // EventTarget은 너무 일반적인 타입이라 버튼의 구체적인 속성에 접근할 수 없음
});
```

```ts
typescriptdocument.querySelector('#myButton').addEventListener('click', (e) => {
    // 타입 단언으로 더 구체적인 타입으로 변환
    const button = e.currentTarget as HTMLButtonElement;

    // 이제 HTMLButtonElement의 속성들에 접근 가능!
    button.disabled = true;
    button.textContent = '클릭됨';
    button.style.backgroundColor = 'red';
});
```

## 10. 객체 래퍼 타입 피하기

-   기본형 타입들은 객체 래퍼 타입이 존재한다.
-   `null`과 `undefined`에는 객체 래퍼가 없다.
-   래퍼 타입이 있기 때문에 기본형 값에 메서드를 사용할 수 있다.

## 11. 초과 프로퍼티 검사

> [excess property](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html#stricter-object-literal-assignment-checks)

TypeScript 1.6은 초과 속성이나 오타가 있는 속성을 잡기 위해 더 엄격한 객체 리터럴 할당 검사를 시행한다.

-   객체 리터럴을 변수에 직접 할당하거나 대상 타입이 존재하는 인수로 전달하게 되면 **초과 프로퍼티 검사가 실행**된다.
    -   이 때 객체 리터럴이 대상 타입에 없는 속성을 갖고 있으면 에러가 발생한다.

```ts
interface Room {
    numDoors: number;
    ceilingHeightFt: number;
}

const r: Room = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present', // ❌ 에러! Room에 없는 속성
};
```

-   객체를 다른 변수를 통해 할당하면 초과 프로퍼티 검사를 받지 않고 **할당 가능 검사**만을 받게 된다.

```ts
const obj = {
    numDoors: 1,
    ceilingHeightFt: 10,
    elephant: 'present', // 여기서는 에러 없음
};

const r: Room = obj; // 할당 가능 검사를 통과하기 때문에 에러가 발생하지 않는다.
```

-   타입 단언문 `as 타입`을 사용하는 경우에도 잉여 속성 체크가 적용되지 않는다.

```ts
const o = { darkmode: true, title: 'Ski Free' } as Options;
```

### 약한 타입 체크

[](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html)

[](https://mariusschulz.com/blog/weak-type-detection-in-typescript)

"약한 타입"이란 모든 속성이 선택적인 타입을 말한다. 약한 타입 체크는 객체 리터럴이든 변수든 상관없이 공통 속성이 없으면 에러가 발생한다.

```ts
interface Options {
    data?: string;
    timeout?: number;
    maxRetries?: number;
}

const temp = { 객체 리터럴}

// 공통 속성이 없으면 에러가 발생하는지
const r1: Options = temp;
const r2: Options = { 객체 리터럴};
```

## 12. 함수 표현식에 타입 적용하기

> 타입스크립트에서는 함수 표현식을 쓰는게 좋다고 함 -> 매개변수/ 반환값 전체를 **함수 타입**으로 선언하여 재사용이 가능하기 때문!

## 13. 타입과 인터페이스의 차이점 알기

타입스크립트에서는 명명된 타입을 정의할 때, `type` 또는 `interface`를 사용할 수 있다.대부분의 상황에서는 둘 중에 하나 골라서 쓰면 됨

-   인덱스 시그니처 둘 다 사용 가능함

```ts
type TState = {
    name: string;
    capital: string;
};

interface IState {}
```

```ts
type TFn = (x: number) => string;

// 호출 시그니처
interface IFn {
    (x: number): string;
}

// 타입 (input: string) => number
const foo: CallSignature = (input) => input.length;
```

단순한 함수의 타입을 선언하는 경우 타입 별칭이 더 나은 선택임

---

## 14.
