# 이펙티브 타스

## **1. 타입 추론 확인**

- 함수 라인에 커서를 올리면 IDE가 타입을 추론해줌.
- 예: number[] 타입인지 [number, number] 같은 페어 타입인지 확인 가능.

---

## **2. 타입을 집합으로 생각하기**

- 타입 시스템을 **집합(부분집합, 전체집합, 공집합)**으로 이해하면 직관적임.

---

## **3. 특수 타입**

- never: **공집합**. 값이 존재할 수 없음.
- unknown: **전체집합**. 모든 타입을 포함.

---

## **4. 상속, 서브타입, 할당 가능성**

- 전부 **부분집합 관계** 개념으로 이해 가능.

---

## **5. 런타임과 타입 시스템**

- instanceof 같은 자바스크립트 기능은 타입에 영향 없음.
- 원시 타입 검증에는 typeof 사용 가능.
- TypeScript에서 정의한 type은 런타임에서는 사라짐.

---

## **6. 타입 단언 (Type Assertion)**

- TypeScript가 알 수 없는 타입(예: HTMLElement)에 접근할 때 단언 필요.
- 이미 좁혀져서 해당 서브타입이 아닌 경우 단언 불가.
- 이럴 때는 **unknown으로 넓힌 후 다시 좁히기**를 사용.

---

## **7. 원시 타입 vs 객체 래퍼 타입**

- string (원시 타입)과 String (객체 래퍼 타입 like 생성자)을 혼동하지 말 것.

---

## **8. 잉여 속성 체크 (Excess Property Check)**

- **객체 리터럴을 바로 대입**하거나 **함수 인자에 직접 넣을 때만** 잉여 속성 체크가 동작.
- 이후부터는 구조적 타이핑으로 동작 → 잉여 속성 체크 안 함.

```
interface Option {
  title: string;
  darkmode?: boolean;
}

const options: Option[] = [
  { title: "Light" },
  { title: "Dark", darkmode: true },
  { title: "System", darkMMMode: undefined }, // 에러
];

function foo(opt: Option) {}

foo({ title: "Dark", darkMMMode: true }); // 에러

const hihihi = { title: "System", darkMMMode: true };

const noLiteral: Option = hihihi; // OK (구조적 타이핑, 잉속체 안함)

// 모든 필드가 옵셔널이면 "약한 타입"
interface WeakOption {
  title?: string;
  darkmode?: boolean;
}
```

---

## **9. 함수 타입 선언**

- 프롭스에서 핸들러 넘길 때 자주 쓰는 패턴.

```
type ClickHandler = (event: MouseEvent) => void;
```

---

## **10. 타입 vs 인터페이스**

- type → 타입 별칭. 유니온 타입 같은 복잡한 타입 정의 가능.
- interface → 선언 병합(라이브러리 타입 확장)에 유리.
- 인터페이스는 유니온 타입을 직접 확장 불가 → &로 타입과 섞어야 함.

정리:

- **type**: 별칭, 복잡한 타입 정의. 스냅샷이라 생각하면 편한듯
- **interface**: 확장과 선언 병합이 필요한 경우.

---

## **11. 인덱스 시그니처**

```
interface StringDict {
  [key: string]: string;
} // 너무 넓음
```

너무 넓으므로 Record, Tuple 등으로 더 좁혀서 사용

---

## **12. Readonly**

- readonly로 불변 타입을 만들 수 있음.

```
type ReadonlyUser = {
  readonly id: number;
  readonly name: string;
}
```
