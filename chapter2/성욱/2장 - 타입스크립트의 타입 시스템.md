## 아이템 6 편집기를 사용하여 타입 시스템 탐색하기

- 타입스크립트 컴파일러 (tsc)
- 타입스크립트 서버 (tsserver)

typeof null === object

편집기에서 타입스크립트 언어 서비스를 적극 활용해야 한다 (제네릭 타입 추론 등등)
타입 선언 파일을 찾아보는 방법을 터득해야 한다 (**.d.ts)

## 아이템 7 타입이 값들의 집합이라고 생각하기

1. never 타입 - 아무 값도 할당할 수 없다
2. 리터럴(유닛) 타입 - 한 가지 값만 포함하는 타입
3. 유니온 타입 - 두 개 이상 묶은 타입

never - 공집합
| 연산 - 합집합
& 연산 - 교집합
extends - ~의 부분 집합
unknown - 전체 집합

## 아이템 8 타입 공간과 값 공간의 심벌 구분하기

심벌 - 타입 공간이나 값 공간 중 한 곳에 존재한다

상황에 따라 `interface Cylinder`와 `const Cylinder`처럼 타입으로 쓰일 수도 있고 값으로 쓰일 수도 있어 오류를 야기한다

컴파일 과정에서 타입 정보는 제거되기 때문에 심벌이 사라지면 타입에 해당된다
:, as 뒤에 나오는 심벌은 타입, = 뒤에 나오는 모든 것은 값이다

## 아이템 9 타입 단언보다는 타입 선언을 사용하기

```
const alice: Person = { name: 'Alice' };
const bob = { name: 'Bob' } as Person;
```
첫번째는 타입 선언
두번째는 타입 단언

타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사
타입 단언은 강제로 타입을 지정했기에 타입 체커에게 오류를 무시하라고 하는 것

타입 단언을 쓰는 경우
- DOM 타입 등 해당 타입에 대해 잘 알고 있는 경우,
- 특별 문법(!)을 사용해서 null이 아님을 단언하는 경우

## 아이템 10 객체 래퍼 타입 피하기

Javascript에는 객체 이외 7가지 타입이 존재
- string
- number
- boolean
- null
- undefined
- symbol (ES2015)
- bigint

기본형들은 불변이고 메서드를 가지지 않는데 메서드를 가지는 객체 타입이 정의되어 있다
ex) `'primitive'.charAt(3)`

자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환하고 `charAt` 같은 메서드를 사용할 때 기본형을 String 객체로 래핑하고 메서드를 호출하고, 마지막에 래핑한 객체를 버린다

래퍼 타입은 실제 타입과 달라서 오류를 발생시킬 수 있다.
ex) `funcion isGreeting(phrase: String) { return ['hello', 'good day'].includes(phrase); }`

## 아이템 11 잉여 속성 체크의 한계 인지하기

잉여 속성은 타입 검사가 되지 않을 때가 있다.
(객체 리터럴이 아닌 경우, 타입 단언문을 사용할 경우)
```
interface Room {
	numDoors: number;
	ceilingHeightFt: number;
}
const r: Room = {
	numDoors: 1,
	ceilingHeightFt: 10,
	elephant: 'present', // 에러
};

const obj = {
	numDoors: 1,
	ceilingHeightFt: 10,
	elephant: 'present',
};
const r: Room = obj; // 정상
```

타입스크립트는 오류만 표시하는 것이 아닌 의도와 다르게 작성된 코드도 찾는다(ex. 대소문자 틀릴시)

## 아이템 12 함수 표현식에 타입 적용하기

Javascript에서는 문장과 함수 표현식을 다르게 인식한다

문장: `funcion rollDice1(sides: number): number { /* ... */ }`
표현식: `const rollDice2 = function(sides: number): number { /* ... */ }`
표현식: `const rollDice3 = (sides: number): number => { /* ... */ }`

타입스크립트에서는 함수의 매개벼누부터 반환값까지 전체를 함수 타입으로 선언할 수 있어 함수 표현식을 사용하는 것이 좋다.
이로 불필요한 코드의 반복을 줄이고 타입 안정성이 높아진다 (타입스크립트에서 함수 매개변수의 타입을 추론할 수 있게 해줌)
```
type DiceRollFn = (sides: number) => number;
const rollDice: DiceRollFn = sides => { /* ... */ };
```

## 아이템 13 타입과 인터페이스의 차이점 알기

### 다른 점
유니온 타입은 있지만 유니온 인터페이스라는 개념은 없다
`type NamedVariable = (Input | Ouput) & { name: string };`

type 키워드는 일반적으로 interface보다 쓰임새가 많다
유니온이 될 수도 있고, 매핑된 타입 또는 조건부 타입 같은 고급 기능에 활용되기도 한다

`type Pair = [number, number];`
해당 튜플도 인터페이스로 구현할 수 있지만 그러면 메서드들을 사용할 수 없다

인터페이스에는 타입에 없는 기능인 '보강(augment)'이 가능하다
```
interface IState {
	name: string;
	capital: string;
}
interface IState {
	population: number;
}
```
이렇게 속성을 확장하는 것을 '선언 병합'이라고 한다

### 결론
type vs interface

복잡한 타입이라면 type
두가지 방법 모두 표현 가능할 때라면 일관성있게 type 또는 interface 사용

스타일이 확립되지 않았다면 향후 보강의 가능성이 있는지 생각해 봐야 한다
어떤 API에 대한 타입이면 보강을 할 경우가 있어 인터페이스로 사용 (새로운 필드를 병합할 수 있어 유용)
하지만 프로젝트 내부적으로 사용되는 타입에 선언 병합은 잘못된 설계다

## 아이템 14 타입 연산과 제너릭 사용으로 반복 줄이기

제네릭 타입은 타입을 위한 함수와 같다
제너릭 타입도 매개변수를 제한할 수 있다 (extends 활용)

`type Pick<T, K> = { [k in K]: T[k] };`
Pick은 T와 K 두가지 타입을 받아서 결과 타입을 반환한다 (Pick 또한 제너릭 타입)

값의 형태에 해당하는 타입을 정의하고 싶을 때는 typeof를 사용
ex) `type Options = typeof INIT_OPTIONS;`
이 코드는 자바스크립트의 런타임이 아닌 타입스크립트 단계에서 연산된다

## 아이템 15 동적 데이터에 인덱스 시그니처 사용하기

`type Rocket = {[property: string]: string};`
- 키의 이름: 키의 위치 표시 용도. 타입 체커에서는 사용하지 않음
- 키의 타입: string이나 number 또는 symbol의 조합이어야한다 (보통 string 사용)
- 값의 타입: 어떤 것이든 될 수 있음

단점:
- 잘못된 키를 포함한 모든 키를 허용
- 특정 키가 필요하지 않음 (`{}`도 유효한 타입으로 간주)
- 키마다 다른 타입을 가질 수 없음
- 자동완성 기능이 제공되지 않음

런타임 때까지 객체의 속성을 알 수 없을 경우에만 사용하는 것이 좋다
안전한 접근을 위해 undefined를 추가하는 것을 고려해야 한다

## 아이템 16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

ArrayLike 타입 - 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶을 때 사용 (배열의 메서드들은 없음)
```
funcion checkedAccess<T>(xs: ArrayLike<T>, i: number): T{
	if (i < xs.length>) {
		return xs[i];
	}
	throw new Error()
}
```

ArrayLike를 사용해도 키는 여전히 문자열이다

## 아이템 17 변경 관련된 오류 방지를 위해 readonly 사용하기

매개 변수를 readonly로 선언하면 다음과 같은 일이 생긴다
- 타입스크립트는 매개변수가 함수 내에서 변경이 일어나는지 체크
- 호출하는 쪽에서는 함수가 매개변수를 변경하지 않는다는 보장을 받게 됨
- 호출하는 쪽에서는 함수에 readonly 배열을 매개변수로 넣을 수 있음

매개변수가 변경되는 것을 방지하여 오류를 방지할 수 있고 변경이 발생하는 코드를 쉽게 찾을 수 있다
readonly는 얕게 동작한다

const array = {
	hello,
	hi,
	aef: {
		hello
	}
}

const object: readonly = Object.freeze(array)

## 아이템 18 매핑된 타입을 사용하여 값을 동기화하기

타입 체커가 동작하도록 코드를 짤 것. 핵심은 매핑된 타입과 객체를 사용

```
const REQUIRES_UPDATE: {[k in keyof Props]: boolean} = {
	xs: true,
	ys: true,
	color: true,
	onClick: false,
};

funcion shouldUpdate (
	oldProps: Props,
	newProps: Props
) {
	let k: keyof Props;
	for (k in oldProps) {
		if (oldProps[k] !== newProps[k] && REQUIRES_UPDATE[k]) {
			return true;
		}
	}
	return false;
}
```

`[k in keyof Props]`은 타입 체커에게 REQUIRE_UPDATE가 Props와 동일한 속성을 가져야 한다는 정보를 제공한다
그러면 나중에 새로운 속성을 추가할 때 REQUIRE_UPDATE 정의에 오류가 발생한다


## 내용 추가

weak type
https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection

=> TypeScript는 완전히 다른 속성들만 가진 객체를 weak type에 할당하는 것을 `실수`라고 가정한다.