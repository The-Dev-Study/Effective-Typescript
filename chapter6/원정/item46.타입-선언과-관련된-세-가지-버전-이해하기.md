# 아이템 46 타입 선언과 관련된 세 가지 버전 이해하기

의존성 관리는 매우 힘든 일이다. 그래서 단순히 라이브러리를 프로젝트에 추가해서 사용할 뿐이지 라이브러리의 전이적 의존성이 호환되는지 깊게 생각하지 않았을거다.

그런데 실제로 타입스크립트는 알아서 의존성 문제를 해결해 주지 않고 의존성 관리를 오히려 더 복잡하게 만든다.

왜냐하면 타입스크립트를 사용하면 다음 세 가지 사항을 추가로 고려해야 하기 때문이다.
- 라이브러리의 버전
- 타입 선언(@types)의 버전
- 타입스크립트의 버전

세 가지 버전 중 하나라도 맞지 않으면, 의존성과 상관없어 보이는 곳애서 엉뚱한 오류가 발생할 수 있다. 이렇게 발생한 오류의 원인을 파악하고 고기 위해서는 타입스크립트 라이브러리 관리의 복잡한 메커니즘을 모두 이해해야 한다.

타입스크립트에서 일반적으로 의존성을 사용하는 방식은 다음과 같다. 특정 라이브러리를 dependencies로 설치하고, 타입 정보를 devDependencies로 설치한다.

``` bash
$ npm install react
+ react@16.8.6

$ npm install --save-dev @types/react
+ @types/react@16.8.19
```

메이저 버전과 마이너 버전이 일치하지만 패치 버전은 일치하지 않는다는 점에 주목해야 한다. @types/react의 16.8.19는 타입 선언들이 리액트 16.8 버전의 API를 나타낸다는 것을 의미한다. 만약 리액트 모듈이 시맨틱 버전 규칙을 제대로 지킨다고 가정하면 패치 버전들은 공개 API의 사양을 변경하지 않는다. 따라서 타입 선언을 업데이트할 필요가 없다. 

그러나 타입 선언 자체에도 버그나 누락이 존재할 수 있으며 @types 모듈의 패치 버전은 버그나 누락으로 인한 수정과 추가에 따른 것이다. 앞선 예제의 경우 라이브러리 자체보다 타입 선언에 더 많은 업데이트가 있었다.

그러나 실제로 라이브러리와 타입 정보 버전이 별도로 관리되는 방식은 다음 네 가지 문제점이 있다.

첫 번째, 라이브러리를 업데이트했지만 실수로 타입 선언은 업데이트하지 않는 경우. 이런 경우 라이브러리 업데이트와 관련된 새로운 기능을 사용하려 할 때마다 타입 오류가 발생하게 된다.

일반적인 해결책은 타입 선언도 업데이트하여 라이브러리와 버전을 맞추는 것이다. 그러나 업데이트해야 할 타입 선언 버전이 아직 준비되지 않은 경우라면 두 가지 선택지가 있다. 보강 기법을 활용하여 사용하려는 새 함수와 메서드 타입 정보를 프로젝트 자체에 추가하는 것이다. 또는 타입 선언의 업데이트를 직접 작성하고 공개하여 커뮤니티에 기여하는 방법도 있다.

두 번재, 라이브러리보다 타입 선언의 버전이 최신인 경우이다. 이런 경우는 타입 정보 없이 라이브러리를 사용해오다가 타입 선언을 설치하려고 할 때 뒤늦게 발생한다. 첫 번째 문제와 상황이 비슷하지만 버전의 대소 관계가 반대다. 타입 체커는 최신 API를 기준으로 코드를 검사하게 되지만 런타임에 실제로 쓰이는 것은 과거 버전이다.

세 번째, 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입스크립트 버전이 최신인 경우. 일반적으로 로대시, 리액트, 람다 같은 유명 자바스크립트 라이브러리의 타입 정보를 더 정확하게 표현하기 위해서 타입스크립트에서 타입 시스템이 개선되고 버전이 올라게 된다. 그러므로 이러한 라이브러리들의 최신 타입 정보를 얻기 위해서라면 당연히 타입스크립트의 최신 버전을 사용해야 한다.
현재 프로젝트보다 라이브러리에게 필요한 타입스크립트 버전이 높은 상황이라면, @types 선언 자체에서 타입 오류가 발생하게 된다. 
이오류를 해결하려면 프로젝트의 타입스크립트 버전을 올리거나, 라이브러리 타입 선언의 버전을 원래대로 내리거나, declare module 선언으로 라이브러리의 타입 정보를 없애버리면 된다. 라이브러리에서 typesVersions를 통해 타입스크립트 버전별로 다른 타입 선언을 제공하는 방법도 있지만 실제로는 매우 드물다.

네 번째, @types 의존성이 중복될 수도 있다. @types/foo와 @types/bar에 의존하는 경우를 가정해보자. 만약 @types/bar가 현재 프로젝트와 호환되지 않는 버전의 @types/foo에 의존한다면 npm은 중첩된 폴더에 별도로 해당 버전을 설치하여 문제를 해결하려고 한다.

런타임에 사용되는 모듈이라면 괜찮을 수 있지만, 전역 네임스페이스에 있는 타입 선언 모듈이라면 대부분 문제가 발생한다. 전역 네임 스페이스에 타입 선언이 존재하면 중복된 선언 또는 선언이 병합될 수 없다는 오류로 나타나게 된다. 이런 상황이라면 npm ls @types/foo를 실행하여 어디서 타입 선언 중복이 발생했는지 추적할 수 있다.
해결책은 보통 @types/foo를 업데이트하거나 @types/bar를 업데이트해서 서로 버전이 호환 되게 하는 것이다. 그러나 @types에 전이 의존성을 가지도록 만드는 것은 종종 문제를 일으키기도 한다. 
일부 라이브러리, 특히 타입스크립트로 작성된 라이브러리들은 자ㅔ적으로 타입 선언을 포함하게 된다. 자체적인 타입 선언은 보통 package.json의 types 필드에서 .d.ts 파일을 가리키도록 되어 있다.

type: index.d.ts를 추가하면 모든 문제가 해결될까?
번들링 하여 타입 선언을 포함하는 경우, 특히 라이브러리가 타입스크립트로 작성되고 컴파일러를 통해 타입 선언이 생성된 경우라면 버전 불일치 문제를 해결하기는 한다. 그러나 번들링 방식은 부수적인 네 가지 문제점을 안고 있다.

첫 번째, 번들된 타입 선언에 보강 기업으로 해결할 수 없는 오류가 있는 경우, 또는 공개 시점에는잘 동작했지만 타입스크립트 버전이 올라가면서 오류가 발생하는 경우에 문제가 된다. @types를 별도로 사용하는 경우라면 라이브러리 자체의 버전에 맞추어 선택할 수 있다. 그러나 번들된 타입에서는 @types의 버전 선택이 불가능하다. 단 하나의 잘못된 타입 선언으로 타입 스트립트의 버전을 올리지 못하는 불상사가 생길 수 있는 것이다. 번들된 타입과 DefinitelyTyped이 비교되는 부분이다.DefinitelyTyped는 점검을 통해 해결되고 있다.

두 번째, 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 의존한다면 문제가 된다. 보통은 의존성이 devDependencies에 들어간다. 그러나 프로젝트를 공개하여 다른 사용자가 설치하게 되면 devDependencies가 설치되지 않을 것이고 타입 오류가 발생하게 된다. 나중에 이러한 상황에 대한 표준 해결책을 다룬다. 한편 DefinitelyTyped에 타입 선언을 공개하는 경우라면 첫 번째 상황은 전혀 문제가 되지 않는다. 타입 선언은 @types에 있을 것이고 타입스크립트 사용자만이 타입 정보를 사용하게 된다.

세 번째, 프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우에는 과거 버전으로 돌아가서 패치 업데이트를 해야 한다. 번들링된 타입 선언에서는 어려운 일이지만, DefinitelyTyped는 동일 라이브러리의 여러 버전의 타입 선언을 동시에 유지보수할 수 있는 매커니즘을 가지고 있다.

네 번째 타입 선언의 패치 업데이트를 자주 하기 어렵다는 문제가 있다. DefinitelyTyped는 커뮤니티에서 관리되기 때문에 이러한 작업량을 감당할 수 있다.

타입스크립트에서 의존성을 관리한다는 것은 쉽지 않은 일이지만, 잘 관리 한다면 그에 따른 보상이 함께 존재한다. 잘 작성된 타입 선언은 라이브러리를 올바르게 사용하는 방법을 배우는 데 도움이 되며 생산성 역이 크게 향상 시킬 수 있다. 만약 의존성 관리에 문제가 생긴다면 이번 아이템의 처음에 언급했던 세 가지 버전을 기억해야 한다.

## 요약
- @types 의존성과 관련된 세 가지 버전이 있다. 라이브러리 버전, @types 버전, 타입스크립트 버전이다.
- 라이브러리를 업데이트 하는 경우, 해당 @types 역시 업데이트해야 한다.
-타입 선언을 라이브러리에 포함하는 것과 DefinitelyTyped에 공개하는 것 사이의 장단점을 이해해야 한다. 타입스크립트로 작성된 라이브러리라면 타입 선언을 자체적으로 포함하고, 자바스크립트로 작성된 라이브러리라면 타입 선언을 DefinitelyTyped에 공개하는 것이 좋다.