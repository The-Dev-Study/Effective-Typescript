# 오버로딩 타입보다는 조건부 타입을 사용하기

```typescript
function double(x) {
	return x + x;
}

// 타입이 구체적이지 않음
function double(x: number | string): number | string;
function double(x: any) { return x + x; }

const num = double(12); // string | number
const str = double('x'); // string | number

// 타입이 과하게 구체적
function double<T extends nunmber | string>(x: T): T;
function double(x: any) { return x + x; }

const num = double(12); // 타입: 12
const str = double('x'); // 타입: "x"

// 조금 더 명확한 타이핑
function double(x: number): number;
function double(x: string): string;
function double(x: any) { return x + x; }

const num = double(12); // 타입: number
const str = double('x'); // 타입: string

// 버그 여전히 존재
function f(x: number | string) {
	return double(x); // string | number 형식의 인수는 'string' 형식의 매개변수에 할당될 수 없습니다.
}

// 제네릭과 유사하지만 반환 타입이 더 정교
function double<T extends number | string>(
	x: T
): T extends string ? string : number;

function double(x: any) { return x + x; }
```