# 콜백에서 this에 대한 타입 제공하기

this는 렉시컬 스코프가 아닌 다이나믹 스코프이기 때문에 혼란스럽다.

this는 객체의 현재 인스턴스를 참조하는 클래스에서 가장 많이 쓰인다.

```typescript
class C {
	vals = [1, 2, 3];
	logSquares() {
		for (const val of this.vals) {
			console.log(val * val);
		}
	}
}

const c = new C();
c.logSquares();

const method = c.logSquares;
method(); // undefined의 'vals' 속성을 읽을 수 없습니다.
```

logSquares가 두가지 작업을 수행한다
1. C.prototype.logSquares를 호출
2. this의 값을 c로 바인딩

`call`을 사용하면 명시적으로 this를 바인딩하여 문제를 해결할 수 있다

```typescript
const c = new C();
const method = c.logSquares;
method.call(c); // 정상
```

this 바인딩은 종종 콜백 함수에 쓰인다.

```typescript
class ResetButton {
	render() {
		// 호출 시점의 this로 바인딩되어 undefined일 수 있다
		return makeButton({text: 'Reset', onClick: this.onClick});
	}
	onClick() {
		alert(`Reset ${this}`); // this 바인딩 문제
	}
}

// 속성 탐색 순서 1. 인스턴스 속성에서 찾음 2. 없으면 프로토타입에서 찾음
class ResetButton {
	constructor() {
		// 개별 인스턴스마다 onClick 속성으로 바인딩
		this.onClick = this.onClick.bind(this);
	}
	render() {
		return makeButton({text: 'Reset', onClick: this.onClick});
	}
	onClick() {
		alert(`Reset ${this}`);
	}
}

// 화살표 함수 사용시 this가 항상 인스턴스를 참조한다
class ResetButton {
	render() {
		return makeButton({text: 'Reset', onClick: this.onClick});
	}
	onClick = () => {
		alert(`Reset ${this}`);
	}
}

```


