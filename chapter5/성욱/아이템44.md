# 타입 커버리지를 추적하여 타입 안정성 유지하기

`noImplicitAny` + `명시적 타입 구문` 사용에도 any 타입 문제로부터 완전히 안전하지 않다

여전히 any타입이 프로그램 내에 존재할 수 있는 경우는 두가지 있다
- 명시적 any 타입
`any[]`, `{[key : string] : any}`같은 타입은 인덱스를 생성하면 단순 any가 되고 코드 전반에 영향을 미친다
- 서드파티 타입 선언
@types 선언 파일로부터 any 타입이 전파되어 특별히 조심해야 한다.

`type-cover-age` 패키지를 활용하여 any를 추적할 수 있다.

`npx type-coverage --detail` 명령어로 any 타입이 있는 곳을 모두 출력해 준다.

any가 등장하는 몇가지 문제:

```typescript
function getColumnInfo(name: string): any {
	return utils.buildColumnInfo(appState.dataSchema, name); // any 반환
}

// 서드파티 라이브러리로부터 비롯되는 any타입의 형태 중 가장 극단적인 예는 전체 모듈이 any 타입을 부여하는 것
declare module 'my-module';

import {someMethod, someSymbol} from 'my-module'; // 정상

const pt1 = {
	x: 1,
	y: 2,
}; // 타입이 {x: number, y: number}
const pt2 = someMethod(pt1, someSymbol); // 정상, pt2의 타입이 any
```

서드파티 라이브러리 타입에 버그가 있는 경우 어쩔 수 없이 any 단언문을 사용해야 한다.
라이브러리가 업데이트되어 제대로 수정되면 any를 제거해야 한다. (주의 필요)