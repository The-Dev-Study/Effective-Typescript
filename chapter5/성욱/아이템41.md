# any의 진화를 이해하기

```typescript
// javacsript
function range(start, limit) {
	const out = [];
	for (let i = start; i < limit; i++) {
		out.push(i);
	}
	return out;
}

// typescript
function range(start: number, limit: number) {
	const out = [];
	for (let i = start; i < limit; i++) {
		out.push(i);
	}
	return out; // 반환 값 number[]로 추론
}
```

> out이 처음에 any 타입 배열인 []로 초기화되었는데 마지막에 number[]로 추론되는 이유

out에 number 타입을 넣는 순간 number[]로 진화한다.
이는 타입 좁히기와는 다르며 배열에 다양한 타입 요소를 넣으면 배열의 타입이 확장되며 진화한다.

```typescript
const result = []; // any[]
result.push('a'); // string[]
result.push(1); // (string | number)[]
```

조건문에서의 타입 진화:

```
let val; // any
if (Math.random() < 0.5) {
	val = /hello/; // RegExp
} else {
	val = 12; // number
}
val // number | RegExp
```

try catch 문에서의 타입 진화:

```typescript
let val = null // any
try {
	somethingDangerous();
	val = 12;
} catch(e) {
	console.warn('warning!');
}
val // number | null
```

> any 타입의 진화는 `noImplicitAny`가 설정된 상태에서 암시적으로 any인 경우에만 일어난다

명시적으로 `any` 타입을 선언하면 타입이 그대로 유지된다.

```typescript
let val: any; // any
if (Math.random() < 0.5) {
	val = /hello/; // any
} else {
	val = 12; // any
}
val // any
```

> 암시적 any 상태인 변수에 어떤 값도 할당하지 않고 사용하려 하면 암시적 any 오류가 발생한다.

```typescript
function range(start: number, limit: number) {
	const out = [];
	if (start === limit) {
		return out; // 암시적 any[]
	}
	// 함수 호출을 거쳐도 암시적 any 타입은 진화하지 않는다
	range(start, limit).forEach(i => {
		out.push(i * i);
	})
	return out; // 암시적 any[]
}
```

암시적 any를 개선하려면 루프로 순회하는 대신 배열의 `map`과 `filter` 메서드를 통해 단일 구문으로 배열을 생성하여 진화시키는 방법이 있다.