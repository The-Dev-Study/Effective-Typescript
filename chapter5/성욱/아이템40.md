# 함수 안으로 타입 단언문 감추기

외부로 드러난 타입 정의는 간단하지만 내부 로직이 복잡해 안전한 타입으로 구현하기 어려운 경우가 많다.
함수 내부에는 타입 단언을 사용하고 외부에 드러나는 타입 정의를 정확히 명시하는 것이 좋다.

```typescript
declare function hallowEqual(a: any, b: any): boolean;
function cacheLast<T extends Function>(fn: T): T {
	let lastArgs: any[] | null = null;
	let lastResult: any;
	return function(...args: any[]) { // '(...arg: any[]) => any' 형식은 'T' 형식에 할당할 수 없습니다.
		if (!lastArgs || !shallowEqual(lastArgs, args)) {
			lastResult = fn(...args);
			lastArgs = args;
		}
		return lastResult;
	}
}

function cacheLast<T extends Function>(fn: T): T {
	let lastArgs: any[] | null = null;
	let lastResult: any;
	return function(...args: any[]) {
		if (!lastArgs || !shallowEqual(lastArgs, args)) {
			lastResult = fn(...args);
			lastArgs = args;
		}
		return lastResult;
	} as unknown as T;
}
```

> 예시 코드이므로 두가지 문제가 존재한다.

1. 함수를 연속으로 호출하는 경우에 this의 값이 동일하지 체크하지 않는다
2. 원본 함수가 객체처럼 속성 값을 가지고 있었다면 래퍼 함수에 속성 값이 없기 때문에 타입이 달라진다.