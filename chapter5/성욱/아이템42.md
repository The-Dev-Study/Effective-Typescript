# 모르는 타입의 값에는 any 대신 unknown을 사용하기

```typescript
interface Book {
	name: string;
	author: string;
}
const book: Book = parseYAML(`
	name: Wuthering
	author: Emily
`);

const book = parseYAML(`
	name: Jane;
	author: Charlotte
`);
alert(book.title); // 오류 없음, 런타임에 "undefined" 경고
book('read'); // 오류 없음, ,런타임에 "TypeError: book은 함수가 아닙니다" 예외 발생

// unknown으로 지정

function safeParseYAML(yaml: string): unknown {
	return parseYAML(yaml);
}
const book = safeParseYAML(`
	name: Hall
	author: Anne
`);
alert(book.title); // ~개체가 'unknown' 형식입니다
book("read"); // ~개체가 'unknown' 형식입니다
```

`할당 가능성의 관점에서` any를 생각해 볼 필요가 있다.

> 1. 어떠한 타입이든 any 타입에 할당 가능하다

> 2. any 타입은 어떠한 타입으로도 할당 가능하다

타입체커가 집합 기반이기 때문에 any를 사용하면 타입 체커가 무용지물이 된다.
`unknown`: 첫번째 속성은 만족, 두번째 속성은 만족하지 않는다. (unknown은 오직 unknown과 any에만 할당 가능)
`never`: 첫번째 속성(어떤 타입도 never에 할당할 수 없음)을 만족하지 않고, 두번째 속성은 만족한다.

```typescript
const book = safeParseYAML(`
	name: Hall
	author: Anne
`) as Book; // unknown 타입을 그대로 사용하면 오류이기 때문에 적절한 Book타입으로 반환
alert(book.title);
book("read");
```

```typescript
// 타입 좁히기
functin processValue(val: unknown) {
	if (val instanceof Date) {
		val // Date 타입
	}
}

function isBook(val: unknown): val is Book {
	return (
		typeof(val) === 'object' && val !== null && 'name' in val && 'author' in val
	);
}
function processValue(val: unknown) {
	if (isBook(val)) {
		val; // Book 타입
	}
}

// 범위 좁히기에 상당히 많은 노력이 필요한 것을 알 수 있다
```

단언문:

```typescript
declare const foo: Foo;
let barAny = foo as any as Bar;
let barUnk = foo as unknown as Bar;
```

> 기능적으로는 동일하다. any의 경우 분리되는 순간 그 영향력이 전염병처럼 퍼지고 unknown의 경우는 분리되는 즉시 오류를 발생하게 된다.

> {} 타입은 null과 undefined를 제외한 모든 값을 포함한다

> object 타입은 모든 비기본형 타입으로 이루어진다. true, 12, "foo"는 포함되지 않지만 객체와 배열은 포함된다