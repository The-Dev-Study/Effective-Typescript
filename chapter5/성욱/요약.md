# Effective TypeScript 5장 any 다루기 - 요약

## 아이템 38: any 타입은 가능한 좁은 범위에서만 사용하기

**핵심 포인트:**
- any 사용 시 최소한의 범위로 제한
- 변수 전체를 any로 선언하지 말고 필요한 부분만 타입 단언 사용

**예시:**
```typescript
// 나쁜 예: 변수 전체가 any
const x: any = expressionReturningFoo();

// 좋은 예: 필요한 곳만 any 단언
const x = expressionReturningFoo();
processBar(x as any);
```

---

## 아이템 39: any를 구체적으로 변형해서 사용하기

**핵심 포인트:**
- 단순 any보다 구체적인 타입 사용으로 안정성 향상
- 함수, 배열, 객체에 맞는 구체적 타입 지정

**예시:**
```typescript
// 나쁜 예: 너무 광범위
function getLength(array: any) { return array.length; }

// 좋은 예: 배열임을 명시
function getLength(array: any[]) { return array.length; }

// 좋은 예: 객체 속성 접근 가능
function processObject(o: {[key: string]: any}) { ... }

// 좋은 예: 함수 타입
type Fn = (...args: any[]) => any;
```

---

## 아이템 40: 함수 안으로 타입 단언문 감추기

**핵심 포인트:**
- 복잡한 내부 로직에는 타입 단언 사용 허용
- 외부 타입 정의는 정확하게 유지

**예시:**
```typescript
function cacheLast<T extends Function>(fn: T): T {
  let lastArgs: any[] | null = null;
  let lastResult: any;
  return function(...args: any[]) {
    // 내부 로직...
    return lastResult;
  } as unknown as T; // 타입 단언으로 반환 타입 맞춤
}
```

---

## 아이템 41: any의 진화를 이해하기

**핵심 포인트:**
- 암시적 any는 값이 할당되면서 타입이 진화
- 명시적 any는 진화하지 않음
- noImplicitAny 설정 시에만 타입 진화 발생

**예시:**
```typescript
const result = []; // any[]
result.push('a'); // string[]
result.push(1); // (string | number)[]

// 조건문에서의 진화
let val; // any
if (Math.random() < 0.5) {
  val = /hello/; // RegExp
} else {
  val = 12; // number
}
val // number | RegExp
```

---

## 아이템 42: 모르는 타입의 값에는 any 대신 unknown을 사용하기

**핵심 포인트:**
- unknown은 안전한 any의 대안
- 타입 좁히기나 단언문 없이는 사용 불가
- any는 전파되지만 unknown은 격리됨

**타입 계층:**
- any: 모든 타입에서 할당 가능, 모든 타입으로 할당 가능
- unknown: 모든 타입에서 할당 가능, unknown/any로만 할당 가능
- never: 어떤 타입에서도 할당 불가, 모든 타입으로 할당 가능

**예시:**
```typescript
// 나쁜 예: any는 모든 작업 허용
function parseYAML(yaml: string): any { ... }

// 좋은 예: unknown은 타입 체크 강제
function safeParseYAML(yaml: string): unknown { ... }

const book = safeParseYAML('...');
// book.title; // 오류: unknown 타입
if (isBook(book)) {
  book.title; // 타입 좁히기 후 사용 가능
}
```

---

## 아이템 43: 몽키 패치보다는 안전한 타입을 사용하기

**핵심 포인트:**
- 객체에 임의 속성 추가보다 타입 보강(augmentation) 사용
- 전역 변수나 프로토타입 수정 시 타입 안전성 확보

**예시:**
```typescript
// 나쁜 예: 타입 안전하지 않음
(document as any).monkey = 'Tamarin';

// 좋은 예: 인터페이스 보강
interface Document {
  monkey: string;
}
document.monkey = 'Tamarin';

// 좋은 예: 모듈에서의 전역 선언
declare global {
  interface Document {
    monkey: string;
  }
}
```

---

## 아이템 44: 타입 커버리지를 추적하여 타입 안정성 유지하기

**핵심 포인트:**
- noImplicitAny 설정만으로는 완전한 타입 안전성 보장 안됨
- type-coverage 도구로 any 타입 추적
- 서드파티 라이브러리의 any 타입 주의

**any가 여전히 존재하는 경우:**
1. **명시적 any 타입**: any[], {[key: string]: any} 등
2. **서드파티 타입 선언**: @types 패키지에서 전파되는 any

**모니터링:**
```bash
npx type-coverage --detail
```

**주의사항:**
- 서드파티 라이브러리 타입 버그로 인한 불가피한 any 사용
- 라이브러리 업데이트 시 any 제거 필요성 검토

---

## 느낀점

- unknown, never 타입의 실사용 케이스를 더 많이 찾아보고 확실하게 개념을 짚고 넘어가야겠다
- 앞으로는 any 타입 커버리지를 확인하는 라이브러리로 테스트하고 타입 안정성을 높히는 방법도 고려해봐야겠다
- any는 아예 사용을 지양하는게 맞다고 생각하지만 javascript에서 마이그레이션하거나 빠른 개발을 위해 명시적 any 타입을 사용하는 것은 좋아 보인다