# 아이템 44 타입 커버리지를 추적하여 타입 안전성 유지하기

noImplicitAny를 설정하고 모든 암시적 any 대신 명시적 타입 구문을 추가해도 any 타입과 관련된 문제들로부터 안전하다고 할 수 없다. any 타입이 여전히 프로그램 내에 존재할 수 있는 두 가지 경우가 있다.

- 명시적 any 타입
아이템 38과 아이템 39의 내용에 따라 any 타입의 범위를 좁히고 구체적으로 만들어도 여전히 any 타입이다. 특히 any[]와 {[key: string]: any} 같은 타입은 인덱스를 생성하면 단순 any가 되고 코드 전반에 영향을 미친다.

- 서드파티 타입 선언
이 경우는 @types 선언 파일로부터 any 타입이 전파되기 때문에 특별히 조심해야 한다. noImplicitAny를 설정하고 절대 any를 사용하지 않았다 하더라도 여전히 any 타입은 코드 전반에 영향을 미친다.

any 타입은 타입 안전성과 생산성에 부정적 영향을 미칠 수 있으므로 프로젝트에서 any의 개수를 추적하는 것이 좋다. npm의 type-cover-age 패키지를 활용하여 any를 추적할 수 있는 몇 가지 방법이 있다.

any가 등장하는 몇 가지 문제와 그 해결책을 살펴보겠다.
표 형태의 데이터에서 어떤 종류의 열 정보를 만들어 내는 함수를 만든다고 가정해보자.

``` tsx
function getColumnInfo(name: string): any {
    return utils.buildColumInfo(appState.dataSchema, name); // any를 반환합니다.
}
```
utils.buildColumInfo 호출은 any를 반환한다. 그래서 geColumnInfo 함수의 반환에는 주석과 함께 명시적으로 : any 구문을 추가했다.

이후에 타입 정보를 추가하기 위해 ColumnInfo를 반환하도록 개선해도 getColumnInfo 함수의 반환문에 있는 any까지 제거해야 문제가 해결된다.

서드파티 라이브러리로부터 비롯되는 any 타입은 몇 가지 형태로 등장할 수 있지만 가장 극단적인 예는 전체 모듈에 any 타입을 부여하는 것이다.

``` tsx
declare module 'my-module';
```

앞의 선언으로 인해 my-module에서 어떤 것이든 오류 없이 임포트할 수 있다. 임포트한 모든 심벌은 any 타입이고, 임포트한 값이 사용되는 곳마다 any 타입을 양산하게 된다.

일반적인 모듈의 사용법과 동일하기 때문에, 타입 정보가 모두 제거됐다는 것을 간과할 수 있다. 또는 동료가 모든 타입 정보를 날려 버렸지만, 알아채지 못하는 경우일 수도 있다. 그렇기 때문에 가끔 해당 모듈을 점검해야 한다.

서드파티 라이브러리로부터 비롯되는 any의 또 다른 형태는 타입에 버그가 있는 경우이다. 예를 들어 아이템 29의 조언(값을 생성할 때는 엄격하게 타입을 적용)을 무시한 채로, 함수가 유니온 타입을 반환하도록 선언하고 실제로는 유니온 타입보다 훨씬 더 특정된 값을 반환하는 경우다. 

선언된 타입과 실제 반환된 타입이 맞지 않는다면 어쩔 수 없이 any 단언문을 사용해야 한다.

## 요약
- noImplicitAny가 설정되어 있어도, 명시적 any 또는 서드파티 타입 선언을 통해 any 타입은 코드 내에 여전히 존재할 수 있다는 점을 주의해야 한다.
- 작성한 프로그램의 타입이 얼마나 잘 선언되었는지 추적해야 한다.
