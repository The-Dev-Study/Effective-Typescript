# 아이템 41. any의 진화를 이해하기 ⭐

> 타입스크립트에서 변수의 타입은 선언될 때 결정되며, 후에 좁히기는 가능하지만 확장을 불가능하다. 그러나 **any 타입과 관련해서는 예외인 경우가 존재한다.**

## any 진화의 조건 ⭐

`any` 타입의 진화는 `noImplicitAny`가 설정된 상태에서 변수의 타입이 **암시적 `any`**인 경우에만 일어난다. <ins>명시적 `any`인 경우에는 타입이 그대로 유지된다.</ins>

```ts
let val: any; // Type is any
if (Math.random() < 0.5) {
    val = /hello/;
    val; // Type is any
} else {
    val = 12;
    val; // Type is any
}
val; // Type is any
```

또한 변수가 **암시적 `any`타입**인 경우, 값을 읽으려고 하면 오류가 발생한다.

⭐⭐

```ts
function range(start: number, limit: number) {
    const out = [];
    //    ~~~ Variable 'out' implicitly has type 'any[]' in some
    //        locations where its type cannot be determined
    if (start === limit) {
        return out;
        //     ~~~ Variable 'out' implicitly has an 'any[]' type
    }
    for (let i = start; i < limit; i++) {
        out.push(i);
    }
    return out;
}
```

## any의 진화 예제 ⭐

```ts
function range(start : number, limit: number;) {
    const out = []; // 타입이 any[]
    for (let i = start; i < limit; i++) {
        out.push(i); // 타입이 any[]
    }
    return out; // 타입이 number[]
}
```

-   `out`의 타입은 `any[]`로 선언되었지만 `number` 타입의 값을 넣는 순간부터 `number[]`로 진화한다.
-   `any[]`에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화한다.

> 타입 안전성을 보장하기 위해서 암시적 `any`를 진화시키는 방법보다는 명시적 타입 구문을 사용하는게 좋다.

## 요약

-   암시적 `any`와 `any[]`는 진화할 수 있다.
-   `any`를 진화시키는 방식보다는 명시적 타입 구문을 사용하는게 더 안전하다.
