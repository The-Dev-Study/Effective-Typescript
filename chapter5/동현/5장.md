# 이펙티브 타스

## Item 38: any 타입은 가능한 한 좁은 범위에서만 사용하기

- any는 최소한의 범위에서만 사용
- 함수의 반환 타입에 절대 any 사용하지 않기

### 1. 함수에서 any 사용법

```tsx
// Bad: any가 외부로 전파됨
function f1() {
  const x: any = expressionReturningFoo()
  processBar(x)
  return x  // any 반환으로 외부에 전파
}

// Good: 내부에서만 any 사용
function f2() {
  const x = expressionReturningFoo()
  processBar(x as any)  // 최소 범위에서만 any
  return x  // 원래 타입 유지
}

```

### 2. 객체에서 any 사용법

```tsx
// Bad: 전체 객체가 타입 체크되지 않음
const config: Config = {
  a: 1,
  b: 2,
  c: { key: value },
} as any

// Good: 필요한 부분만 any 사용
const config: Config = {
  a: 1,      // 타입 체크됨
  b: 2,      // 타입 체크됨
  c: { key: value as any },  // 최소 범위
}

```

### 3. @ts-ignore 활용

근본적인 원인을 해결할 수 없는 경우에만 사용

---

## Item 39: any를 구체적으로 변형해서 사용하기

### 핵심 포인트

- any보다 더 구체적인 타입 사용하기
- 배열, 객체, 함수에 맞는 구체적인 any 형태 활용

### 1. 배열의 경우

```tsx
// Bad
function getLengthBad(array: any) {
  return array.length  // 반환 타입이 any
}

// Good
function getLength(array: any[]) {
  return array.length  // 반환 타입이 number
}

```

### 2. 객체의 경우

```tsx
// object 타입: 열거만 가능, 프로퍼티 접근 불가
function hasTwelveLetterKey(o: object) {
  for (const key in o) {
    console.log(o[key])  // 에러 발생
  }
}

// 인덱스 시그니처: 프로퍼티 접근 가능
function hasTwelveLetterKey(o: {[key: string]: any}) {
  for (const key in o) {
    console.log(o[key])  // 정상 동작
  }
}

```

### 3. 함수의 경우

```tsx
type Fn0 = () => any                 // 매개변수 없음
type Fn1 = (arg: any) => any         // 매개변수 1개
type FnN = (...args: any[]) => any   // 매개변수 여러개

```

---

## Item 40: 함수 안으로 타입 단언문 감추기

- 복잡한 내부 로직에서 any 사용 시 함수 내부에 숨기기
- 외부로 드러나는 타입 정의는 정확하게 명시

### 캐싱 함수 예시

```tsx
function cacheLast<T extends Function>(fn: T): T {
  let lastArgs: any[] | null = null
  let lastResult: any

  return function (...args: any[]) {
    if (!lastArgs || !shallowEqual(lastArgs, args)) {
      lastResult = fn(...args)
      lastArgs = args
    }
    return lastResult
  } as unknown as T  // 타입 단언으로 T 타입 보장
}

```

### 객체 비교 함수 예시

```tsx
function shallowObjectEqual<T extends object>(a: T, b: T): boolean {
  for (const [k, aVal] of Object.entries(a)) {
    if (!(k in b) || aVal !== (b as any)[k]) {  // 내부에서만 any 사용
      return false
    }
  }
  return Object.keys(a).length === Object.keys(b).length
}

```

---

## Item 41: any의 진화를 이해하기

- 암시적 any는 값 할당 시 타입이 진화함
- 명시적 any는 진화하지 않음

### 1. any의 진화 과정

```tsx
function range(start: number, limit: number) {
  const out = []  // any[]로 시작
  for (let i = start; i < limit; i++) {
    out.push(i)   // number를 추가하면 number[]로 진화
  }
  return out      // 최종적으로 number[] 반환
}

```

### 2. 다양한 타입의 진화

```tsx
const result = []     // any[]
result.push('a')      // string[]
result.push(1)        // (string | number)[]

```

### 3. 조건문에서의 진화

```tsx
let val  // any
if (Math.random() < 0.5) {
  val = /hello/
  val    // RegExp
} else {
  val = 12
  val    // number
}
val      // number | RegExp
```

### 4. 명시적 any는 진화하지 않음

```tsx
let val: any = null  // 명시적 any
if (Math.random() < 0.5) {
  val = /hello/
  val  // 여전히 any
}

```

---

## Item 42: 모르는 타입의 값에는 any 대신 unknown 사용하기

- unknown은 타입 안전한 any의 대안
- 사용 전 타입 체크 강제로 안전성 확보

### 1. any vs unknown 할당 규칙

```tsx
// any의 특징 (위험함)
// - 어떤 타입이든 any에 할당 가능
// - any는 어떤 타입으로도 할당 가능

// unknown의 특징 (안전함)
// - 어떤 타입이든 unknown에 할당 가능
// - unknown은 오직 unknown과 any에만 할당 가능

```

### 2. 사용 예시

```tsx
function parseYAML(yaml: string): unknown {  // any 대신 unknown
  return JSON.parse(yaml)
}

const book = parseYAML(`name: Jane Eyre`)
// book.title  // ❌ 에러: 'unknown' 형식
(book as Book).title  // ✅ 타입 단언 후 사용

```

### 3. unknown 타입 좁히기

```tsx
function processValue(val: unknown) {
  if (val instanceof Date) {
    val  // Date 타입으로 좁혀짐
  }

  if (isBook(val)) {  // 타입 가드 사용
    val  // Book 타입으로 좁혀짐
  }
}

```

### 4. 타입 범위 비교

```
unknown > object > {}
```

- `unknown`: 모든 값
- `object`: 원시 타입 제외한 모든 타입
- `{}`: null과 undefined 제외한 모든 값

---

## Item 43: 몽키 패치보다는 안전한 타입 사용하기

- 전역 변수나 DOM에 속성 추가 시 타입 안전성 확보
- any 단언보다는 interface 보강이나 구체적 타입 사용

### 1. 문제가 되는 방식

```tsx
// ❌ any 단언 사용
(document as any).monkey = 'Tamarin'
(document as any).monky = 'Tamarin'   // 오타 체크 안됨
(document as any).monkey = /Tamarin/  // 잘못된 타입도 허용

```

### 2. Interface 보강 (권장)

```tsx
interface Document {
  monkey: string
}

document.monkey = 'Tamarin'  // ✅ 타입 안전

```

### 3. 모듈 관점에서 보강

```tsx
declare global {
  interface Document {
    monkey: string
  }
}
```

### 4. 구체적인 타입 확장

```tsx
interface MonkeyDocument extends Document {
  monkey: string
}

(document as MonkeyDocument).monkey = 'Macaque'  // ✅ 안전한 타입 단언
```

---

## Item 44: 타입 커버리지를 추적하여 타입 안정성 유지하기

- noImplicitAny로도 모든 any를 제거할 수 없음
- 도구를 사용해 any 추적하고 관리하기

### 1. any가 남아있는 경우들

- 명시적 any 선언
- 서드파티 타입 선언에서 오는 any
- 전체 모듈을 any로 선언하는 경우

### 2. type-coverage 도구 사용

```bash
# 설치
npm install -D type-coverage

# 실행
npx type-coverage
# 출력: 9985 / 10117 98.69%

# 상세 정보
npx type-coverage --detail

```

### 3. 서드파티 모듈 문제

```tsx
// ts에 이런 모듈이 있다고 정의 보통 d.ts로 선언하는 파일안에 넣곤 함 jest 초기세팅같이
declare module 'my-module';

import { someMethod } from 'my-module'
const result = someMethod()  // result는 any 타입
```

---

## 전체 요약

1. **any 사용 최소화**: 정말 필요한 경우에만 최소 범위에서 사용
2. **구체적인 any**: any보다는 any[], {[key: string]: any} 등 구체적 형태 사용
3. **unknown 활용**: 타입을 모르는 경우 any 대신 unknown 사용
4. **타입 단언 숨기기**: 복잡한 로직에서 불가피한 any는 함수 내부에 숨기기
5. **안전한 확장**: 몽키 패치보다는 interface 보강이나 구체적 타입 사용
6. **지속적 관리**: 도구를 활용해 any 사용량 추적하고 점진적으로 개선

사실 어떤 프로젝트에서도 any를 사용해본적이 없고 앞으로도 없지않을까.. 린트룰에 박혀있으니