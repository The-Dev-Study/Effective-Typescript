# 이펙티브 타스

### **추론 가능한 타입에는 명시하지 말기**

- 기본값이나 리터럴 등에서 타입이 충분히 추론되는 경우에는 **불필요한 타입 선언을 피하고**, 코드의 간결함과 유지보수성을 확보하는 것이 좋다.

  예:

```tsx
// 나쁨
let x: number = 12;
// 좋음
let x = 12;
```

- 복잡한 객체나 리터럴, 함수 반환도 추론이 가능한 경우가 많다. 되도록 타입스크립트의 추론 결과를 신뢰하고 활용하자.

---

### **명시적인 타입이 필요한 경우**

- 특히 **함수 시그니처**(매개변수, 반환 타입)는 타입이 명확하게 드러나야 하므로 **직접 명시하는 것이 좋다**.
- 마찬가지로, 객체 리터럴에 타입을 지정하면 잉여 속성 체크가 활성화되어 오류를 조기에 잡을 수 있다.
- 비동기 함수나 Promise 반환 같은 경우, 반환 타입을 지정하지 않으면 **불일치**로 인해 오류를 유발할 수 있다. 명시적으로 반환 타입을 선언하자.

---

### **타입 넓히기 (Widening) 이해하기**

- 타입스크립트는 값을 초기화할 때 “넓은 타입”으로 추론하는 경향이 있다.

  예: let x = "x"; → x의 타입은 "x"가 아닌 string으로 넓게 추론됨.

- 이를 피하려면 const 선언, as const 단언, 상황에 맞는 타입 구문 등을 사용하여 **의도한 좁은 타입**을 지정할 수 있다.

---

### **타입 좁히기 (Narrowing) 활용하기**

- 조건문(if), instanceof, in 연산자, Array.isArray() 등을 통해 넓은 타입에서 **구체적인 타입으로 좁히는 방법**을 적극 활용하자.
- **태그된 유니온(공통된 식별자 속성(tag)을 가진 여러 타입을 합쳐놓은 유니온 타입)**, switch, **사용자 정의 타입 가드(custom type guard)** 등을 사용하면 더욱 명확한 타입 분기가 가능하다.
- 사용자 정의 타입 가드

```tsx
interface Dog {
  kind: "dog";
  bark: () => void;
}
interface Cat {
  kind: "cat";
  meow: () => void;
}

function isDog(animal: Dog | Cat): animal is Dog {
  return animal.kind === "dog";
}

function makeSound(animal: Dog | Cat) {
  if (isDog(animal)) {
    // 여기선 Dog 타입으로 좁혀짐
    animal.bark();
  } else {
    animal.meow();
  }
}
```

---

### **한꺼번에 객체 생성하기**

- 객체를 속성 하나씩 단계적으로 할당하는 방식은 타입 추론에 혼란을 줄 수 있다. **한 번에 필요한 속성을 모아서 객체를 선언**하는 것이 좋다.
- **스프레드 연산자**를 활용하면 객체를 안전하게 합칠 수 있으며, 타입 시스템도 이를 추론할 수 있다. (다중 테이블 필터 걸때 유용함)

---

### **일관성 있는 별칭 사용**

- 변수나 객체 속성에 별칭(alias)을 줄 때, **일관성있게 사용하지 않으면** 타입 추론 및 제어 흐름 분석이 방해될 수 있다(사이드이펙트 유발).
- 구조분해할당(destructuring)을 사용하면 가독성과 추론 안정성을 확보할 수 있다.

## 개인적인 생각

lodash 지향 맞는지 잘 모르겠음. pipe()로 코드 예뻐지는거 보고 괜찮아 보이긴 했는데 특정 상황에만 좋은 것 같다고 느낌

if, isArray 아니면 타입 좁힐때 보통 as로 퉁쳤었음 런타임 타입추론을 위해 in, instanceof를 쓰는것에 약간 거부감이 있긴함 잘 쓸 상황도 나오지 않았음
