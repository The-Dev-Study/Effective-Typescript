# 비동기 코드에는 콜백 대신 async 함수 사용하기

ES2015에서 콜백 지옥을 극복하기 위해 프로미스 (promise) 개념을 도입했다.

```
const page1Promise = fetch(url1);
page1Promise.then(response1 => {
	return fetch(url2);
}).then(response2 => {
	return fetch(url3);
}).then(response3 => {
	// ...
}).catch(error => {
	// ...
})
```

실행 순서가 코드 순서와 같아지고 중첩이 적어졌다.

ES2017에서는 async, await 키워드를 도입해서 더 간단하게 만들었다.

```
async function fetchPages() {
	const response1 = await fetch(url1);
	const response2 = await fetch(url2);
	const response3 = await fetch(url3);
}
```

await 키워드는 각각의 프로미스가 처리될 때까지 함수의 실행을 멈춘다.
async 함수 내에서 만약 프로미스가 거절되면 예외를 던진다.

병렬로 페이지를 로드하고 싶다면 다음처럼 Promise.all을 활용할 수 있다.

```
async function fetchPages(){
	const [response1, resopnse2, response3] = await Promise.all([
		fetch(url1), fetch(url2), fetch(url3)
	]);
	// ...
}
```

프로미스를 사용하면 타입스크립트의 모든 타입 추론이 제대로 동작한다.

```
// function getNumber(): Prommise<number>
async function getNumber() {
	return 42;
}

// async 화살표 함수
const getNumber = async () => 42; // () => Promise<number>

// 프로미스 직접 생성
const getNumber = () => Promise.resolve(42); // () => Promise<number>
```

프로미스를 직접 생성하는게 이상해 보일 수 있으나 비동기, 동기는 혼용해서 사용하면 좋지 않기에 비동기로 일부러 만들기도 한다.
예를 들어 캐싱 함수를 만든다하면 동기로 만들었을 때 사용하기 무척 까다로워진다.


## 요약
- 콜백보다는 프로미스를 사용하는게 코드 작성과 타입 추론 면에서 유리하다.
- 가능하면 프로미스를 생성하는 것보다는 async/await를 사용하는 것이 좋다.
- 어떤 함수가 프로미스를 반환한다면 async로 선언하는 것이 좋다.