# 타입 좁히기

타입 좁히기는 넓히기와 반대로 가장 일반적인 예시가 null 체크이다.

```
const el = document.getElementById('foo'); // HTMLElement | null
if (el) { // HTMLElement
	// ...
} else { // null
	// ...
}
```

이렇게 조건문으로 타입을 좁히는게 가능하다

```
function contains(text: string, search: string | RegExp) {
	if (search instanceof RegExp) {
		search // 타입이 RegExp
		return !!search.exec(text);
	}
	search // 타입이 string
	return text.includes(search);
}
```

instanceof를 활용하여 이렇게 좁힐 수도 있고 속성 체크, Array.isArray같은 내장함수로도 좁힐 수 있다.

```
interface A {a: number}
interface B {b: number}
function pickAB(ab: A | B) {
	if ('a' in ab) {
		ab // 타입이 A
	} else {
		ab // 타입이 B
	}
	ab // 타입이 A | B
}
```

**_typeof null = "object" 를 주의해야 한다._**
**_빈 문자열 ''과 0 모두 false가 되기 때문에 이것도 주의가 필요하다._**

```
interface UploadEvent { type: 'upload'; filename: string; contents: string }
interface DownloadEvent { type: 'download'; filename: string; }
type AppEvent = UploadEvent | DownloadEvent;
function handleEvent(e: AppEvent) {
	switch (e.type) {
		case 'download':
			e  // 타입이 DownloadEvent
			break;
		case 'upload':
			e  // 타입이 UploadEvent
			break;
	}
}
```

이 패턴은 '태그된 유니온(tagged union)' 또는 '구별된 유니온(discriminated union)'이라고 부른다.

타입 스크립트가 타입을 식별하지 못한다면 커스텀 함수를 도입할 수 있다.

```
function isInputElement(el: HTMLElement): el is HTMLInputElement {
	return 'value' in el;
}
```

이런 기법을 `사용자 정의 타입 가드`라고 한다.

```
const jackson5 = ['Jackie', 'Tito', 'Jermaine'];
const members = ['Janet', 'Michael'].map(
	who => jackson5.find(n => n === who)
) // 타입이 (string | undefined)[]

const members = ['Janet', 'Michael'].map(
	who => jackson5.find(n => n === who)
).filter(who => who !== undefined); // 타입이 (string | undefined)[]

function isDefined<T>(x: T | undefined): x is T {
	return x !== undefined;
}
const members = ['Janet', 'Michael'].map(
	who => jackson5.find(n => n === who)
).filter(isDefined); // 타입이 string[]
```

## 요약

- 조건문, 속성 체크, isArray 같은 내장함수 등을 활용해서 타입을 좁힐 수 있다.
- 태그된/구별된 유니온과 사용자 정의 타입 가드를 활용해서 타입을 좁힐 수 있다.
