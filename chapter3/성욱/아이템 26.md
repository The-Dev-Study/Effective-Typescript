# 타입 추론에 문맥이 어떻게 사용되는지 이해하기

타입이 추론될 때 단순히 값만 고려하지는 않는다.
값이 존재하는 곳의 문맥까지 살핀다.

```
// 인라인
setLanguage('Javascript');

// 참조
let language = 'JavaScript';
setLanguage(language);

function setLanguage(language: Language) { /* ... */ }
```

인라인 형태에서는 함수 선언에서 매개변수가 해당 string을 포함한 타입이라는 것을 유추할 수 있지만
참조 형태에서는 language 변수 값 자체로 할당 시점에 타입을 추론하여 함수 매개변수 타입과 다르다는 에러를 보여줄 수 있다.

해법은 두 가지다
1. `let language: Language = 'Javascript';`
2. `const language: Language = 'JavaScript';`

const는 타입 체커에게 language를 변경할 수 없다고 알려줘서 더 정확한 타입인 문자열 리터럴로 추론하는 것이다.

튜플 타입에서도 같은 문제가 발생한다.

```
function panto(where: [number, number]) { /* ... */ }

panTo([10, 20]) // 정상

const loc = [10, 20];
panTo(loc); // 에러 ('number[]' 형식의 인수는 '[number, number]' 형식의 매개변수에 할당될 수 없습니다)
```

다음과 같이 변경하면 해결

```
const loc: [number, number] = [10, 20];
panTo(loc); // 정상

const loc = [10, 20] as const;
panTo(loc); // readonly 타입으로 에러 => 함수 매개변수에도 readonly 타입으로 추가해주면 정상
```

큰 객체에서 상수를 뽑아낼 때도 문제 발생

```
type Language = 'Javascript' | 'Typescript' | 'Python';
interface GovernedLanguage {
	language: Language;
	organization: string;
}

function complain(language: GovernedLanguage) { /* ... */ }

complain({ language: 'Typescript', organization: 'Microsoft' }); // 정상

const ts = {
	language: 'Typescript',
	organization: 'Microsoft',
}

complain(ts); // 오류
```

## 요약
- 타입 추론이 문맥에서 어떻게 쓰이는지 알아야 한다 (값으로 선언되어 쓰일 때와 함수 인라인으로 쓰일 때)
- 변수를 별도로 선언하면 타입 선언을 추가해야 한다
- 객체는 as const를 사용해서 readonly로 만들어 정상으로 만들 수 있다