### **1. 타입스크립트의 타입 검사 특성**

- tsc 할때 타입 체크 수행
- 트랜스파일된 JS 코드에서는 **타입 정보가 사라짐**
- **런타임에 변하는 데이터**(예: API 응답)는 타입스크립트로 검증 불가

    → 런타임 타입 체크는 직접 작성 필요 (zod 사용)


---

### **2. 함수 오버로딩**

- TS는 **함수 오버로딩** 시그니처 정의 가능
- 하지만 트랜스파일 시 **구현체만 남음**

```tsx
function greet(name: string): string;
function greet(age: number): string;
function greet(value: any) { return `Hello ${value}`; }
```

↓ 컴파일 후 JS

```jsx
function greet(value) { return `Hello ${value}`; }
```

- **타입 정보는 완전히 제거됨**

---

### **3. 덕 타이핑 (Duck Typing, JS)**

- **런타임**에서 판단
- 필요한 필드·메서드가 있으면 같은 타입처럼 취급
- 예: 오리, 까만 오리 → 둘 다 quack(), swim()메서드 있으면 오리

```tsx
// "꽥꽥 소리내고 헤엄칠 수 있으면 오리다!"
if (animal.quack && animal.swim) {
  // 오리로 취급
}
```

---

### **4. 구조적 타이핑 (Structural Typing, TS)**

- **컴파일 타임**에서 판단
- 구조(필드와 타입)가 맞으면 같은 타입으로 간주
- **추가 필드가 있어도** 필수 필드만 맞으면 호환됨

```tsx
type Animal = { name: string };
type Dog = { name: string; breed: string };

const dog: Dog = { name: "멍멍이", breed: "리트리버" };
const animal: Animal = dog; // 허용
```

- 안전하지만, **의도치 않은 타입 호환** 가능

---

### **5. any 사용 지양**

- any는 타입 검사 무력화 → 사이드이펙트 유발
- 대신 unknown 사용(이거도 안쓰지만) + 타입 좁히기 필요
- json.parse같이 런타임에 결정되는 경우에도 암시적 any쓰긴 합니다 : unknown붙히기 싫어서..

---

## **비교 표**

| **구분** | **덕 타이핑 (JS)** | **구조적 타이핑 (TS)** |
| --- | --- | --- |
| 시점 | 런타임 | 컴파일 타임 |
| 판단 기준 | 동작 가능 여부 | 구조(속성·타입) |
| 장점 | 유연성 | 타입 안정성 |
| 단점 | 실행 중 오류 가능 | 의도치 않은 호환 가능 |
