# 아이템 5: any 타입 지양하기

`any` 타입은 타입스크립트의 모든 장점을 포기하는 것과 같다. 특별한 경우를 제외하고는 `any` 사용을 지양해야 한다.

## any에서 비롯된 점진적이고 선택적인 TS 타입 시스템

타입스크립트의 타입 시스템은 **점진적**이고 **선택적**이다

-   **점진적:** 코드에 타입을 조금씩 추가할 수 있다
-   **선택적:** 언제든지 타입 체커를 해제할 수 있다

```jsx
let age: number;
age = '12';
// ~~~~~~~ Type 'string' is not assignable to type 'number'.
age = '12' as any;  // OK
```

타입 체커를 통해 잡아낸 오류들은 `as any`를 추가해서 해결할 수 있다. 하지만 이는 문제를 감추는 것일 뿐, 실제로 해결하는 것이 아니다.

## `any`의 위험성

### 1. 타입 안정성이 없다.

`any`는 타입스크립트의 타입 체커를 완전히 무력화시킨다.

```jsx
let age: number;
age = '12' as any;
age += 1;
console.log(age); // "121" - 문자열 연결이 발생
```

-   `age`는 `number` 타입으로 선언되었지만 실제로는 문자열
-   `age + 1`이 숫자 덧셈이 아닌 문자열 연결로 동작
-   컴파일 시점에는 오류가 없지만 런타임에서 예상치 못한 결과를 초래함

### 2. 함수 시그니처를 무시한다.

함수를 작성할 때에는 시그니처(매개변수와 반환값의 이름 / 타입)를 명시해야 한다. `any`타입을 사용하게 되면 매개변수와 반환값의 타입이 무의미해진다.

```jsx
function calculateAge(birthDate: Date): number {
    // ...
}

let birthDate: any = '1990-01-19'; // 문자열
calculateAge(birthDate); // 런타임 오류 발생 가능성이 있음
```

### 3. 언어 서비스가 적용되지 않는다.

IDE의 자동완성, 오류 검사, 리팩터링 도구 등을 사용할 수 없다.

```jsx
// ❌ any 타입 - 자동완성 없음
let person: any = { name: 'John', age: 30 };
person.na; // 자동완성으로 'name'을 제안하지 않음
person.invalidProperty; // 오류 표시 안됨

// ✅ 타입 정의 - 풍부한 언어 서비스
interface Person {
    name: string;
    age: number;
}
let typedPerson: Person = { name: 'John', age: 30 };
typedPerson.na; // 'name' 자동완성 제안
typedPerson.invalidProperty; // ❌ 컴파일 오류
```

### 4. 코드 리팩터링 때 버그를 감춘다.

```jsx
interface ComponentProps {
    onSelectItem: (item: any) => void;
}

renderSelector({ onSelectItem: handleSelect });

// 나중에 onSelectItem의 시그니처를 변경
interface ComponentProps {
    onSelectItem: (id: string, item: Item) => void; // 매개변수 변경
}

// any 때문에 이 코드는 오류가 발생하지 않음
const handleSelect = (item: any) => {
    console.log(item.id); // 런타임에서 오류 발생 가능
};
```

### 5. 타입 설계를 감춘다.

`any`를 사용하면 코드를 읽는 사람이 데이터의 구조를 파악하기 어렵다.

```jsx
// ❌ 의도를 알 수 없는 코드
function processData(data: any): any {
    return data.items.map((item: any) => ({
        id: item.id,
        name: item.name,
        value: item.amount * 1.1,
    }));
}

// ✅ 의도가 명확한 코드
interface Item {
    id: string;
    name: string;
    amount: number;
}

interface ProcessedItem {
    id: string;
    name: string;
    value: number;
}

function processData(data: { items: Item[] }): ProcessedItem[] {
    return data.items.map((item) => ({
        id: item.id,
        name: item.name,
        value: item.amount * 1.1, // 10% 수수료 추가
    }));
}
```

### 6. 타입시스템의 신뢰도를 떨어뜨린다.

`any`가 많이 사용된 코드베이스에서는 타입 정보를 신뢰하기 어렵다.

```jsx
// any가 섞여있어서 실제 타입을 알기 어려움
interface User {
    id: string;
    profile: any; // 이게 뭘까?
    settings: any; // 이게 뭘까?
}

function updateUser(user: User): any {
    // 반환값도 알 수 없음
}
```
