# 아이템 4: 구조적 타이핑에 익숙해지기

타입스크립트는 **구조적 타이핑**을 사용한다. 이는 값의 형태(구조)가 타입을 결정한다는 의미로, 명목적 타이핑과는 완전히 다른 접근법이다.

> "타입스크립트는 매개변수의 값이 요구사항을 만족한다면, 타입이 무엇인지 신경쓰지 않는다"

## 덕 타이핑에서 구조적 타이핑으로

### JS의 덕 타이핑

> "만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거린다면 그것은 오리다."

덕 타이핑이란, 객체가 어떤 타입에 부합하는 변수와 메서드를 갖는 경우 객체를 해당 타입에 속하는 거로 간주하는 방식이다.

```jsx
// JavaScript의 덕 타이핑
function makeSound(animal) {
    animal.quack(); // quack 메서드만 있으면 동작
}

const duck = { quack: () => console.log('Quack!') };
const robot = { quack: () => console.log('Beep!') };

makeSound(duck); // "Quack!"
makeSound(robot); // "Beep!" - 로봇이지만 quack 메서드가 있어서 동작
```

### TS의 구조적 타이핑

타입스크립트는 JavaScript의 덕 타이핑을 **구조적 타이핑**으로 모델링한다.

```jsx
interface Vector2D {
    x: number;
    y: number;
}

interface NamedVector {
    name: string;
    x: number;
    y: number;
}

function calculateLength(v: Vector2D) {
    return Math.sqrt(v.x ** 2 + v.y ** 2);
}

const v1: Vector2D = { x: 2, y: 3 };
const v2: NamedVector = { x: 3, y: 4, name: '벡터' };

console.log(calculateLength(v1)); // 3.605...
console.log(calculateLength(v2)); // 5 - NamedVector도 x, y를 가지므로 호환된다.
```

-   `Vector2D`와 `NamedVector`의 관계 선언이 없다
-   `NamedVector`가 `Vector2D`의 모든 속성을 포함하므로 호환이 가능하다.

## 구조적 타이핑의 장점과 활용

### 유연한 타입 호환성

구조적 타이핑은 유연한 타입 호환성을 갖기 때문에, 다음과 같은 코드를 작성할 수 있다.

```jsx
interface User {
    name: string;
    email: string;
}

interface Admin {
    name: string;
    email: string;
    permissions: string[];
}

function sendEmail(user: User) {
    console.log(`Sending email to ${user.name} at ${user.email}`);
}

const admin: Admin = {
    name: 'Alice',
    email: 'alice@example.com',
    permissions: ['read', 'write', 'delete'],
};

// Admin 타입이지만 User의 구조를 포함하므로 사용 가능
sendEmail(admin); // ✅ 정상 동작함
```

## 구조적 타이핑으로 인한 문제들

### 예상치 못한 타입 호환성

```jsx
interface Vector2D {
    x: number;
    y: number;
}

interface Vector3D {
    x: number;
    y: number;
    z: number;
}

function calculateLength2D(v: Vector2D) {
    return Math.sqrt(v.x ** 2 + v.y ** 2);
}

function normalize3D(v: Vector3D) {
    const length = calculateLength2D(v); // ❌ 버그! 2D 계산을 3D에 사용
    return {
        x: v.x / length,
        y: v.y / length,
        z: v.z / length, // z 좌표가 정규화에서 누락됨
    };
}

const vector3D: Vector3D = { x: 3, y: 4, z: 5 };
const normalized = normalize3D(vector3D);
console.log(normalized); // { x: 0.6, y: 0.8, z: 1 } - 잘못된 결과!
```

-   `Vector3D`가 `Vector2D`의 구조를 포함하므로 타입 체커 통과
-   실제로는 2D 벡터 계산을 3D 벡터에 잘못 적용
-   논리적 오류가 타입 시스템으로 잡히지 않음

> 타입스크립트의 타입 시스템은 타입 확장에 열려있다. 매개변수의 타입으로 선언된 속성만 갖지 않을 수 있다.

### 클래스와 구조적 타이핑의

타입스크립트에서는 클래스도 구조로 판단되기 때문에 예상치 못한 동작이 발생할 수 있다.

```jsx
class C {
    foo: string;
    constructor(foo: string) {
        this.foo = foo;
    }
}

const c = new C('instance of C');
const d: C = { foo: 'object literal' }; // 정상!
```

-   c는 클래스로 만든 인스턴스이다.
    -   `new C()`로 생성한 진짜 C클래스 객체이다.
-   d는 그냥 객체 리터럴이다.
    -   `{ foo: 'object literal'}`은 클래스 인스턴스가 아닌 일반 객체이다.
-   클래스 `C`가 요구하는 구조인 `foo: string`속성만 갖는 다면 같은 타입으로 판단한다.
