# 아이템 3: 코드 생성과 타입이 관계없음을 이해하기

## 타입스크립트 컴파일러의 두 가지 역할

타입스크립트 컴파일러는 두 가지 독립적인 역할을 수행한다. 이 때, 두 역할은 **독립성**을 갖기 때문에, 타입 오류가 있어도 컴파일이 가능하다

### 1️⃣ 타입 오류 검사

타입스크립트는 **정적 분석**을 통해 코드를 검사하며, JavaScript 런타임에서 발생할 수 있는 오류를 사전에 감지한다.

```jsx
function add(a: number, b: number): number {
    return a + b;
}

add('hello', 'world'); // ❌ 타입 오류 발생
```

### 2️⃣ 최신 TS/JS → 구버전 JS 변환 (트랜스파일링)

타입 검사와 별도로, 코드를 런타임 환경에서 동작할 수 있도록 구버전 JavaScript로 변환한다.

```jsx
// 입력: TypeScript/ES2020
const greet = (name: string): string => `Hello, ${name}!`;
const numbers = [1, 2, 3];
const doubled = numbers.map((x) => x * 2);
```

```jsx
// 출력: ES5 JavaScript
function greet(name) {
    return 'Hello, ' + name + '!';
}
var numbers = [1, 2, 3];
var doubled = numbers.map(function (x) {
    return x * 2;
});
```

-   이 때, 모든 타입 정보들이 완전히 제거된다.
-   `const`나 화살표 함수와 같은 ES2020문법이 ES5로 변환된다.

## 런타임과 타입체크

타입스크립트 코드는 자바스크립트 코드로 컴파일되는 과정에서 **인터페이스, 타입, 타입 구문이 제거**된다. 따라서 <ins>런타임 시점에는 타입 체크 코드가 작동하지 않는다.</ins>

```jsx
interface Square {
    width: number;
}
interface Rectangle extends Square {
    height: number;
}
type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
    if (shape instanceof Rectangle) {
        //                 ~~~~~~~~~ 'Rectangle' only refers to a type,
        //                           but is being used as a value here
        return shape.height * shape.width;
        //           ~~~~~~ Property 'height' does not exist on type 'Shape'
    } else {
        return shape.width * shape.width;
    }
}
```

-   위 코드에서 `instanceof` 체크는 런타임에 일어난다.
-   하지만 `Rectangle`은 인터페이스이므로 컴파일 후에는 존재하지 않는다. -따라서 런타임에 `Rectangle`을 값으로 사용할 수 없다

### 해결방법 1: 속성의 존재유무 확인하기

```jsx
function calculateArea(shape: Shape) {
    if ('height' in shape) {
        return shape.width * shape.height;
        //     ^? (parameter) shape: Rectangle
    } else {
        return shape.width * shape.width;
    }
}
```

-   `'height' in shape`는 런타임에 실제로 실행되는 코드이다
-   이를 통해 `shape`의 타입을 정확히 추론할 수 있다

### 해결방법 2: tag 기법 사용하기

`tag`기법을 사용해서 런타임에 타입 정보를 손쉽게 유지할 수도 있다.

```jsx
interface Square {
    kind: 'square'; // 런타임에도 존재하는 타입 구분자
    width: number;
}
interface Rectangle {
    kind: 'rectangle'; // 런타임에도 존재하는 타입 구분자
    height: number;
    width: number;
}
type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
    if (shape.kind === 'rectangle') {
        return shape.width * shape.height;
        //     ^? (parameter) shape: Rectangle
    } else {
        return shape.width * shape.width;
        //     ^? (parameter) shape: Square
    }
}
```

-   `kind` 속성은 런타임에 실제로 존재하는 값이다
-   타입 체크와 런타임 검사를 동시에 만족한다

### 해결방법 3: 타입을 클래스로 변경하기

인터페이스는 타입으로만 사용가능하지만, **클래스는 타입과 값으로 모두 사용할 수 있다**.

```jsx
class Square {
    width: number;
    constructor(width: number) {
        this.width = width;
    }
}
class Rectangle extends Square {
    height: number;
    constructor(width: number, height: number) {
        super(width);
        this.height = height;
    }
}
type Shape = Square | Rectangle; // 타입으로 참조

function calculateArea(shape: Shape) {
    if (shape instanceof Rectangle) {
        // 값으로 참조 - 런타임에 작동!
        return shape.width * shape.height;
        //     ^? (parameter) shape: Rectangle
    } else {
        return shape.width * shape.width;
        //     ^? (parameter) shape: Square
    }
}
```

-   클래스는 컴파일 후에도 자바스크립트에 함수로 남아있다
-   따라서 `instanceof` 체크가 런타임에 정상 작동한다

## 런타임과 타입 연산

타입 연산은 런타임에는 **아무런 영향을 주지 않는다**.

```jsx
function asNumber(val: number | string): number {
  return val as number; // 타입 단언
}

console.log(asNumber("123")); // "123" (문자열 그대로)
```

위 코드는 다음과 같이 컴파일된다.

```jsx
function asNumber(val) {
    return val; // 타입 단언은 완전히 사라짐
}
```

-   `as number`는 타입스크립트에게 "이 값을 number로 취급해달라"고 알려주는 것일 뿐
-   실제로 값을 변환하지는 않는다
-   런타임에서는 아무 일도 일어나지 않는다

## 런타임 타입과 선언된 타입의 차이

```jsx
function setLightSwitch(value: boolean) {
    switch (value) {
        case true:
            turnLightOn();
            break;
        case false:
            turnLightOff();
            break;
        default:
            console.log(`I'm afraid I can't do that.`);
    }
}
```

위 코드에서 `value`는 `boolean` 타입이고, `true` 또는 `false`의 값만 될 수 있기 때문에 `default` 문은 실행되지 않을 거라고 생각할 수 있다.

> 그러나 런타임 시점에 `value` 옆의 `:boolean`은 사라지기 때문에 boolean 값이 아닌 value가 들어온다면 default가 실행되게 된다.

## 타입스크립트 함수 오버로드의 한계

타입스크립트에서 타입은 런타임의 동작과 무관하기 때문에, 타입에 따른 함수 오버로딩은 불가능하다.

### 잘못된 오버로드

```jsx
function add(a: number, b: number) {
    return a + b;
}
//       ~~~ Duplicate function implementation
function add(a: string, b: string) {
    return a + b;
}
//       ~~~ Duplicate function implementation
```

### 올바른 오버로드

```jsx
// 여러 개의 타입 시그니처 선언
function add(a: number, b: number): number;
function add(a: string, b: string): string;

// 구현체는 하나
function add(a: any, b: any): any {
    return a + b;
}
```

오버로딩 기능을 지원하긴 하지만 여러 개의 선언문을 작성하여도 **구현체는 오직 하나**이다.
