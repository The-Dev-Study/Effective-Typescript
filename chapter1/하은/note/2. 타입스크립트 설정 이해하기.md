# 아이템 2: 타입스크립트 설정 이해하기

타입스크립트 컴파일러는 직접 설정이 가능하다. 이 때, 어떻게 설정하는지에 따라 같은 코드가 옳은 코드일 수도 있고 오류 코드가 될 수도 있다.

## `tsconfig.json` 설정 파일 이해하기

### 설정 파일 생성 및 구조

#### 생성하기

```cmd
tsc --init
```

#### 기본 구조

```json
{
    "compilerOptions": {
        // 컴파일러 동작 설정
        "target": "es2020", // 컴파일 결과물의 ECMAScript 버전
        "module": "commonjs", // 모듈 시스템
        "lib": ["es2020", "dom"], // 사용할 라이브러리
        "outDir": "./dist", // 컴파일 결과물 폴더
        "rootDir": "./src", // 소스 파일 폴더

        // 타입 체크 강도 설정
        "strict": true, // 모든 엄격한 타입 체크 옵션 활성화
        "noImplicitAny": true, // 암시적 any 타입 금지
        "strictNullChecks": true, // null/undefined 체크 강화

        // 추가 체크 옵션
        "noUnusedLocals": true, // 사용하지 않는 지역 변수 체크
        "noUnusedParameters": true, // 사용하지 않는 매개변수 체크
        "noImplicitReturns": true // 함수의 모든 경로에서 반환값 체크
    },
    "include": ["src/**/*"], // 컴파일할 파일 패턴
    "exclude": ["node_modules"] // 제외할 파일 패턴
}
```

### 핵심 설정 옵션

#### 1. `noImplicitAny` - 암시적 any 타입 제어

이 설정은 타입스크립트가 타입을 추론할 수 없을 때 `any` 타입으로 간주하는 것을 방지한다.

##### `noImplicitAny: false`

```jsx
function add(a, b) {
    // a, b가 암시적으로 any 타입
    return a + b; // 어떤 타입이든 허용
}

add(10, 20); // 30
add('hello', 'world'); // "helloworld"
add([], {}); // "[object Object]" - 의도하지 않은 결과
```

##### `noImplicitAny: true`

```ts
function add(a, b) {
    // ❌ 컴파일 오류 발생
    return a + b;
}
// Parameter 'a' implicitly has an 'any' type.
// Parameter 'b' implicitly has an 'any' type.

// 해결방법 1: 명시적 타입 지정
function add(a: number, b: number): number {
    return a + b;
}

// 해결방법 2: 타입 추론 활용
const add = (a: number, b: number) => a + b;
```

> 타입스크립트의 장점은 타입 정보를 가져야 효과가 있기 떄문에, 되도록이면 `noImplicitAny`를 설정하고 타입을 명시하며 코드를 작성하는게 좋다.

#### 2. `strictNullChecks` - null/undefined 안전성 강화

이 설정은 `null`과 `undefined`를 다른 타입과 구분하여 처리한다.

##### `strictNullChecks: false`

```ts
interface User {
    name: string;
    email: string;
}

function getUser(): User {
    return null; // 타입 오류 없음
}

const user = getUser();
console.log(user.name.toUpperCase()); // 런타임에 오류가 발생함
// Cannot read property 'name' of null
```

##### `strictNullChecks: true`

```jsx
interface User {
    name: string;
    email: string;
}

function getUser(): User | null {
    // 명시적으로 null 가능성을 표현할 수 있음
    // API 호출 실패 시 null을 반환할 수도 있으니까
    return Math.random() > 0.5 ? { name: 'John', email: 'john@example.com' } : null;
}

const user = getUser();

// ❌ 직접 접근 시 컴파일 오류
console.log(user.name); // Object is possibly 'null'

// 안전한 접근 방법
// 방법 1: null 체크
if (user !== null) {
    console.log(user.name.toUpperCase());
}

// 방법 2: 옵셔널 체이닝
console.log(user?.name?.toUpperCase());

// 방법 3: null 병합 연산자
const userName = user?.name ?? 'Unknown';
```

#### 3. `strict` - 모든 엄격한 검사 활성화

`strict: true`는 다음 모든 옵션을 한 번에 활성화한다.

-   `noImplicitAny`
-   `strictNullChecks`
-   `strictFunctionTypes`
-   `strictBindCallApply`
-   `strictPropertyInitialization`
-   `noImplicitReturns`
-   `noImplicitThis`
