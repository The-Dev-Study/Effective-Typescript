# 1장 타입스크립트 알아보기

타입스크립트 - 사용면에서 독특
인터프리터(파이썬/루비)로 실행되는 것도 아니고 저수준 언어(자바/C)로 컴파일되는 것도 아님
다른 고수준 언어인 자바스크립트로 컴파일. 실행 역시 자바스크립트로 이루어짐

## 아이템 1 - 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트 - 자바스크립트의 상위 집합

문법의 유효성과 동작의 이슈는 독립적인 문제

js, jsx - ts, tsx 바꾼다고 달라지는 것이 없음
마이그레이션에 엄청난 이점

자바스크립트 = 타입스크립트 O
타입스크립트 = 자바스크립트 X

타입 추론
타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것 - '정적' 타입 시스템이라는 것의 특징
타입 체커가 모든 오류를 찾아내지는 않는다.

오류가 발생하지 않지만 의도와 다르게 동작하는 코드를 찾아내기도함
속성이 없는 경우와 같은 코드의 '의도'가 무엇인지 찾아볼 수 있음

capitol, capital 예시

## 아이템 2 - 타입스크립트 설정 이해하기

`tsc --noImplicityAny program.ts` or
tsconfig.json 설정 파일을 통해서도 가능

가급적 설정 파일을 사용하는 것이 좋다 -> 동료들이나 다른 도구들이 알 수 있기 때문
설정 파일은 `tsc --init`만 실행하면 간단히 생성

설정
- 어디서 소스 파일을 찾을지 설정
- 어떤 종류의 출력을 생성할지 설정
- 언어 자체의 핵심 요소들을 제어하는 설정
- 어떻게 설정하느냐에 따라 완전히 다른 언어처럼 느껴질 수 있다

`noImplicitAny`, `strictNullChecks`를 이해해야 한다

noImplicityAny: 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어 // true면 `function add(a, b){//...}`는 오류
strictNullChecks: null과 undefined가 모든 타입에서 허용되는지 확인 // true면 `const x: number = null`은 오류

## 아이템 3 - 코드 생성과 타입이 관계없음을 이해하기

타입스크립트 컴파일러 역할
- 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일한다
- 코드의 타입 오류를 체크

이 두가지가 서로 완벽히 독립적이다.
타입스크립트가 자바스크립트로 변환될 때 코드 내의 타입에는 영향을 주지 않는다
자바스크립트의 실행 시점에도 타입은 영향을 미치지 않는다

### 1. 타입 오류가 있는 코드도 컴파일이 가능하다
- 컴파일은 타입 체크와 독립적으로 동작하기 때문, C나 자바로 치면 경고와 비슷
- 오류가 있을 때 컴파일하지 않으려면 `noEmitOnError` 옵션을 적용하면 됨

### 2. 런타임에는 타입 체크가 불가능하다
```
interface Rectangle extends Square {
	height: number;
}

// Rectangle은 타입이기 때문에 런타임 시점에 아무런 역할을 할 수 없다
if (shape instance of Rectangle) {
	// ...
}
```

### 3. 타입 연산은 런타임에 영향을 주지 않는다
```
// typescript
function asNumber(val: number | string): number {
	return val as number;
}

// javascript
function asNumber(val) {
	return val;
}
```

### 4. 런타임 타입은 선언된 타입과 다를 수 있다
- 아래 코드 예시는 자바스크립트라면 console 실행 가능(boolean 타입이 아닐 때)
- 순수 타입스크립트에서도 실행 가능한 경우: Api로 받아온 타입이 실제로는 boolean 타입이 아닌 경우
```
function setLightSwitch(value: boolean) {
	switch (value) {
		case true:
			turnLightOn();
			break;
		case false:
			turnLightOff();
			break;
		default:
			console.log(`실행`);
	}
}
```

### 5. 타입스크립트 타입으로는 함수를 오버로드할 수 없다
- 함수 오버로딩: 동일한 이름에 매개변수만 다른 여러 버전의 함수 허용
- 쓰려면 아이템 50 참고
```
// typescript
function add(a: number, b: number): number;
function add(a: string, b: string): number;

// javascript
function add(a, b) {
	return a + b;
}
```

### 6. 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다
- 타입과 타입 연산자는 자바스크립트 변환 시점에 제거된다
- 정적 타입은 실제로 비용이 전혀 들지 않는다
- '런타임' 오버헤드 X, '빌드타임' 오버헤드 O
- 오버헤드가 커지면 빌드 도구에서 '트랜스파일만'을 설정하여 타입 체크를 건너뛸 수 있다
- 호환성 높이고 성능 오버헤드 감안 or 호환성 포기하고 성능 중심의 네이티브 구현체


## 아이템 4 - 구조적 타이핑에 익숙해지기

자바스크립트는 덕 타이핑 기반
어떤 함수의 매개변수 값이 모두 제대로 주어진다면 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용한다
타입스크립트는 이런 동작, 매개변수 값이 요구사항을 만족한다면 타입이 무엇인지 신경 쓰지 않는 동작을 그대로 모델링한다
클래스 역시 구조적 타이핑 규칙을 따른다. 클래스의 인스턴스가 예상과 다를 수 있다.
유닛 테스팅을 손쉽게 할 수 있다.

### 예시 1
```
interface Vector2D {
	x: number;
	y: number;
}

function calculateLength(v: Vector2D) {
	return MAth.sqrt(v.x * v.x + v.y * v.y);
}

interface NamedVector {
	name: string;
	x: number;
	y: number;
}

const v: NamedVector = {x: 3, y: 4, name: 'Zee'};
calculateLength(v); // 정상 동작, Vector2D와 NamedVector의 관계 선언이 없는데 호환 가능
```

구조적 타이핑 때문에 문제가 발생하기도 한다

### 예시 2

```
interface Vector3D {
	x: number;
	y: number;
	z: number;
}

function normalize(v: Vector3D) {
	// calculateLength는 Vector2D 기반 연산이어서 버그 발생 => 하지만 타입 체커가 문제를 잡지 못한다
	const length = calculateLength(v);
}
```

이런 오류를 잡기 위한 설정이 존재 - 아이템 37

```
function calculateLength1(v: Vector3D) {
	let length = 0;

	for (const axis of Object.keys(v)) {
		const coord = v[axis]; // 타입스크립트 에러: 'string'은 'Vector3D'의 인덱스로 사용할 수 없어 암시적으로 'any' 타입
		length += Math.abs(coord);
	}
	return length;
}
```
정확한 타입으로 객체를 순회하는 것은 까다로움 - 아이템 54


### 예시 3

```
interface DB {
	runQuery: (sql: string) => any[];
}

function getAuthors(database: DB): Author[] {
	const authorRows = database.runQuery(`SELECT FIRST, LAST FROM AUTHORS`);
	return authorRows.map(row => ({first: row[0], lats: row[1]}));
}

```

라이브러리 간의 의존성을 완벽히 분리할 수 있다 - 아이템 51

## 아이템 5 - any 타입 지양하기

타입 시스템은 타입을 조금씩 추가할 수 있기 때문에 `점진적`이며,
언제든지 타입 체커를 해제할 수 있기 때문에 `선택적`이다.

오류는 언제든지 as any를 추가해 해결할 수 있다. 하지만 이럴 경우 수많은 장점을 누릴 수 없게 된다.
결론: any 타입은 타입체커와 타입스크립트 언어 서비스를 무력화시키고 진짜 문제점을 감추며, 개발 경험을 나쁘게 하고, 타입 시스템의 신뢰도를 떨어뜨린다. 최대한 사용을 피하자.

- any 타입에는 타입 안정성이 없다
- any는 함수 시그니처를 무시해 버린다 (함수가 받는 prop의 타입 무시)
- any 타입에는 언어 서비스가 적용되지 않는다 (자동완성 기능, 심벌에 제공되는 도움말 사용 불가)
- any 타입은 코드 리팩터링 때 버그를 감춥니다
- any 타입은 설계를 감춰버립니다
- any는 타입시스템의 신뢰도를 떨어뜨립니다 (타입체커는 사람의 실수를 잡고 코드의 신뢰도를 높힘) - any 단점 보완은 5장에서 자세히


## 추가 조사

### tsconfig
https://www.typescriptlang.org/tsconfig/
```
⭐️ strict: true // false로 쓰면 typescript 쓰는 이유가 퇴색됨
⭐️ esModuleInterop: true // `import * as React from "react"; => import React from "react";`
allowJs: true // js,ts 둘다 허용 javascript -> typescript로 전환할 때 유용
target: es2016 // es5는 인터넷 익스플로러에서 돌아갈 수 있는 코드로 만듦
module: commonjs // es2022, es2015, 등등
forceConsistentCastingInFileNames: true // 윈도우에서는 import 파일명 대소문자 구분을 하지 않지만 리눅스, 맥은 구분을 해서 에러가 나기 때문에 대소문자 구분 강제하는 옵션
skipLibCheck: true // 라이브러리의 .d.ts 파일들 체크 건너뛰기
```

### 런타임 코드
실행 시점에 결정되는 코드

```
// 1. 컴파일 타임에 결정되는 것들 (정적)
function add(a, b) {    // 함수 정의 - 미리 정해짐
    return a + b;
}

const PI = 3.14159;     // 상수 값 - 미리 정해짐

// 2. 런타임에 실행되는 것들 (동적)
console.log("시작!");           // 실행될 때 출력됨
const result = add(5, 3);       // 실행될 때 계산됨  
const userInput = prompt("?");  // 실행될 때 사용자 입력 받음
```

Javascript 실행 환경
- Mozilla's SpiderMonkey (Firefox, Servo, and Flow)
- Google's V8 (Chrome and Chromium-based browsers ex. Opera, Edge, and Brave)
- Apple's JavaScriptCore (also known as SquirrelFish/Nitro, used in Safari and other WebKit-based browsers)

실행 환경에 따른 문제점
- API 지원 차이 (serviceWorker, IntersectionObserver, 등등)
- CSS 지원 차이 (flexbox flex-basis: auto 버그, has 선택자, scrollbar 스타일링, 등등)
- 이벤트 시스템 차이 (터치 이벤트, 키보드 이벤트, 등등)
- 이런 문제들(주로 ios safari, IE 11 지원을 위한)을 babel, polyfill, PostCSS 같은 도구들이 필수가 됨

### 구조적 타이핑
https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#structural-type-system

- 객체의 **실제 구조(멤버)**를 기반으로 타입 호환성을 판단하는 방식
- Java, C의 구조체는 명목적 타이핑
```
interface User {
    name: string;
    age: number;
}

interface Person {
    name: string;
    age: number;
    email: string; // 추가 프로퍼티
}

const person: Person = { name: "John", age: 30, email: "john@example.com" };
const user: User = person; // ✅ Person이 User의 모든 프로퍼티를 포함

// 반대는 불가능
// const person2: Person = user; // ❌ email 프로퍼티 누락
```
- 왜 Typescript는 구조적 타이핑 방식을 채택?
- Duck Typing이란?